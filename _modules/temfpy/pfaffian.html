

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>temfpy.pfaffian &mdash; TeMFpy 2025 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=9edc463e" />
      <link rel="stylesheet" type="text/css" href="../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=b9ceff23" />

  
    <link rel="shortcut icon" href="../../_static/favicon.svg"/>
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=cb975c41"></script>
      <script src="../../_static/doctools.js?v=fd6eb6e6"></script>
      <script src="../../_static/sphinx_highlight.js?v=6ffebe34"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            TeMFpy
              <img src="../../_static/logo.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/contribute.html">Contributors’ guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../getting_started/contribute.html#best-practices">Best practices</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../getting_started/contribute.html#discuss-before-you-contribute">Discuss before you contribute</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../getting_started/contribute.html#no-giant-prs">No giant PRs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../getting_started/contribute.html#document-your-changes">Document your changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../getting_started/contribute.html#coding-style">Coding style</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../getting_started/contribute.html#how-to-submit-a-pr">How to submit a PR</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/citing.html">Citing TeMFpy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/examples.html">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../examples/gutzwiller.html">gutzwiller.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/iMPS.html">iMPS.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/iMPS_pfaffian.html">iMPS_pfaffian.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/iMPS_slater.html">iMPS_slater.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/pfaffian.html">pfaffian.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/slater.html">slater.py</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#temfpy-0-3-in-development">TeMFpy 0.3 (In development)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#api-breaking-changes">API breaking changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#new-features">New features</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#bug-fixes">Bug fixes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#temfpy-0-2-1-28-january-2026">TeMFpy 0.2.1 (28 January 2026)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#id1">Bug fixes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#temfpy-0-2-23-january-2026">TeMFpy 0.2 (23 January 2026)</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../reference/slater.html">slater</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../reference/slater.html#classes">Classes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes"><code class="docutils literal notranslate"><span class="pre">SchmidtModes</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.e"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.e</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.vL"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.vL</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.vR"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.vR</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.ixL"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.ixL</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.ixR"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.ixR</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.nL"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.nL</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.nR"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.nR</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.n_fermion"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.n_fermion</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.n_entangled"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.n_entangled</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.size"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.size()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.n_filled"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.n_filled()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.vL_entangled"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.vL_entangled</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.vR_entangled"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.vR_entangled</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.mode_vectors"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.mode_vectors()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.eigenvalues"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.eigenvalues()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.singular_values"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.singular_values</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.from_correlation_matrix"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.from_correlation_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.e_ratio"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.e_ratio</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.embed_subsets"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.embed_subsets()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.schmidt_values"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.schmidt_values()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.modes"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.modes</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.left_sets"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.left_sets</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.right_sets"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.right_sets</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.schmidt_values"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.schmidt_values</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.idx_L"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.idx_L</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.n_schmidt"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.n_schmidt</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.n_entangled"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.n_entangled</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.nL"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.nL</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.nR"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.nR</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.n_fermion"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.n_fermion</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.size"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.size()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.vL"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.vL</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.vR"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.vR</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.mode_vectors"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.mode_vectors()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.sets"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.sets()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.from_schmidt_modes"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.from_schmidt_modes()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.from_correlation_matrix"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.from_correlation_matrix()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.MPSTensorData"><code class="docutils literal notranslate"><span class="pre">MPSTensorData</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.MPSTensorData.mode"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.mode</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.MPSTensorData.physical_leg"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.physical_leg</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.MPSTensorData.det_always"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.det_always</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.MPSTensorData.sometimes_matrix"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.sometimes_matrix</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.MPSTensorData.idx_bra"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.idx_bra</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.MPSTensorData.idx_ket"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.idx_ket</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.MPSTensorData.new_sets_bra"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.new_sets_bra</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.MPSTensorData.new_sets_ket"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.new_sets_ket</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.MPSTensorData.qtotal"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.qtotal</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.MPSTensorData.idx_physical"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.idx_physical</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.MPSTensorData.from_schmidt_vectors"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.from_schmidt_vectors()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.MPSTensorData.to_npc_array"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.to_npc_array()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/slater.html#functions">Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.correlation_matrix"><code class="docutils literal notranslate"><span class="pre">correlation_matrix()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.spinful_correlation_matrix"><code class="docutils literal notranslate"><span class="pre">spinful_correlation_matrix()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.C_to_MPS"><code class="docutils literal notranslate"><span class="pre">C_to_MPS()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.C_to_iMPS"><code class="docutils literal notranslate"><span class="pre">C_to_iMPS()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.H_to_MPS"><code class="docutils literal notranslate"><span class="pre">H_to_MPS()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.H_to_iMPS"><code class="docutils literal notranslate"><span class="pre">H_to_iMPS()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/pfaffian.html">pfaffian</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../reference/pfaffian.html#representing-nambu-correlation-matrices">Representing Nambu correlation matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/pfaffian.html#classes">Classes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes"><code class="docutils literal notranslate"><span class="pre">SchmidtModes</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.nL"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.nL</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.nR"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.nR</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.e"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.e</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.vL"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.vL</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.vR"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.vR</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.pL"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.pL</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.pR"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.pR</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.parity"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.parity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.n_entangled"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.n_entangled</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.size"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.size()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.vL_entangled"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.vL_entangled</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.vR_entangled"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.vR_entangled</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.mode_vectors"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.mode_vectors()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.eigenvalues"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.eigenvalues()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.singular_values"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.singular_values</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.from_correlation_matrix"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.from_correlation_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.e_ratio"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.e_ratio</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.embed_subsets"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.embed_subsets()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.schmidt_values"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.schmidt_values()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.modes"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.modes</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.left_sets"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.left_sets</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.right_sets"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.right_sets</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.schmidt_values"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.schmidt_values</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.idx_n"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.idx_n</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.idx_parity"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.idx_parity</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.n_schmidt"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.n_schmidt</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.n_entangled"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.n_entangled</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.nL"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.nL</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.nR"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.nR</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.size"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.size()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.vL"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.vL</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.vR"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.vR</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.mode_vectors"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.mode_vectors()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.pL"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.pL</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.pR"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.pR</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.parity"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.parity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.sets"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.sets()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.from_schmidt_modes"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.from_schmidt_modes()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.from_correlation_matrix"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.from_correlation_matrix()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData"><code class="docutils literal notranslate"><span class="pre">MPSTensorData</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData.mode"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.mode</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData.norm"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.norm</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData.pfaffian_matrix"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.pfaffian_matrix</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData.labels"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.labels</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData.qtotal"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.qtotal</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData.leg_bra"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.leg_bra</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData.new_sets_bra"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.new_sets_bra</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData.idx_n_bra"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.idx_n_bra</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData.leg_idx_bra"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.leg_idx_bra</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData.leg_ket"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.leg_ket</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData.new_sets_ket"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.new_sets_ket</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData.idx_n_ket"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.idx_n_ket</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData.from_schmidt_vectors"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.from_schmidt_vectors()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData.to_npc_array"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.to_npc_array()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/pfaffian.html#high-level-functions">High-level functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.correlation_matrix"><code class="docutils literal notranslate"><span class="pre">correlation_matrix()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.parity"><code class="docutils literal notranslate"><span class="pre">parity()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.C_to_MPS"><code class="docutils literal notranslate"><span class="pre">C_to_MPS()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.C_to_iMPS"><code class="docutils literal notranslate"><span class="pre">C_to_iMPS()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.H_to_MPS"><code class="docutils literal notranslate"><span class="pre">H_to_MPS()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.H_to_iMPS"><code class="docutils literal notranslate"><span class="pre">H_to_iMPS()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/pfaffian.html#helper-functions">Helper functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.vector_C2M"><code class="docutils literal notranslate"><span class="pre">vector_C2M()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.vector_M2C"><code class="docutils literal notranslate"><span class="pre">vector_M2C()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.matrix_C2M"><code class="docutils literal notranslate"><span class="pre">matrix_C2M()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.matrix_M2C"><code class="docutils literal notranslate"><span class="pre">matrix_M2C()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.assert_nambu"><code class="docutils literal notranslate"><span class="pre">assert_nambu()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.assert_nambu_hamiltonian"><code class="docutils literal notranslate"><span class="pre">assert_nambu_hamiltonian()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.assert_nambu_correlation"><code class="docutils literal notranslate"><span class="pre">assert_nambu_correlation()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/iMPS.html">iMPS</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../reference/iMPS.html#temfpy.iMPS.MPS_to_iMPS"><code class="docutils literal notranslate"><span class="pre">MPS_to_iMPS()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/iMPS.html#temfpy.iMPS.overlap_schmidt"><code class="docutils literal notranslate"><span class="pre">overlap_schmidt()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/iMPS.html#temfpy.iMPS.basis_rotation"><code class="docutils literal notranslate"><span class="pre">basis_rotation()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/iMPS.html#temfpy.iMPS.iMPSError"><code class="docutils literal notranslate"><span class="pre">iMPSError</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/iMPS.html#temfpy.iMPS.iMPSError.left_unitary"><code class="docutils literal notranslate"><span class="pre">iMPSError.left_unitary</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/iMPS.html#temfpy.iMPS.iMPSError.left_schmidt"><code class="docutils literal notranslate"><span class="pre">iMPSError.left_schmidt</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/iMPS.html#temfpy.iMPS.iMPSError.right_unitary"><code class="docutils literal notranslate"><span class="pre">iMPSError.right_unitary</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/iMPS.html#temfpy.iMPS.iMPSError.right_schmidt"><code class="docutils literal notranslate"><span class="pre">iMPSError.right_schmidt</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/iMPS.html#temfpy.iMPS.iMPSError.left_total"><code class="docutils literal notranslate"><span class="pre">iMPSError.left_total</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/iMPS.html#temfpy.iMPS.iMPSError.right_total"><code class="docutils literal notranslate"><span class="pre">iMPSError.right_total</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/iMPS.html#temfpy.iMPS.iMPSError.total_error"><code class="docutils literal notranslate"><span class="pre">iMPSError.total_error</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/gutzwiller.html">gutzwiller</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../reference/gutzwiller.html#gutzwiller-projections-of-abrikosov-fermions">Gutzwiller projections of Abrikosov fermions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/gutzwiller.html#temfpy.gutzwiller.abrikosov"><code class="docutils literal notranslate"><span class="pre">abrikosov()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/gutzwiller.html#temfpy.gutzwiller.abrikosov_ph"><code class="docutils literal notranslate"><span class="pre">abrikosov_ph()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/gutzwiller.html#helper-functions">Helper functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/gutzwiller.html#temfpy.gutzwiller.parity_mask"><code class="docutils literal notranslate"><span class="pre">parity_mask()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/gutzwiller.html#temfpy.gutzwiller.number_mask"><code class="docutils literal notranslate"><span class="pre">number_mask()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/testing.html">testing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../reference/testing.html#temfpy.testing.TEST_ACTION"><code class="docutils literal notranslate"><span class="pre">TEST_ACTION</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/testing.html#testing-functions">Testing functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/testing.html#temfpy.testing.assert_allclose"><code class="docutils literal notranslate"><span class="pre">assert_allclose()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/testing.html#temfpy.testing.assert_array_less"><code class="docutils literal notranslate"><span class="pre">assert_array_less()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/testing.html#temfpy.testing.check_schmidt_decomposition"><code class="docutils literal notranslate"><span class="pre">check_schmidt_decomposition()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/testing.html#temfpy.testing.ComparisonWarning"><code class="docutils literal notranslate"><span class="pre">ComparisonWarning</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/schmidt_utils.html">schmidt_utils</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../reference/schmidt_utils.html#temfpy.schmidt_utils.StoppingCondition"><code class="docutils literal notranslate"><span class="pre">StoppingCondition</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/schmidt_utils.html#temfpy.schmidt_utils.StoppingCondition.sectors"><code class="docutils literal notranslate"><span class="pre">StoppingCondition.sectors</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/schmidt_utils.html#temfpy.schmidt_utils.StoppingCondition.chi_max"><code class="docutils literal notranslate"><span class="pre">StoppingCondition.chi_max</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/schmidt_utils.html#temfpy.schmidt_utils.StoppingCondition.svd_min"><code class="docutils literal notranslate"><span class="pre">StoppingCondition.svd_min</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/schmidt_utils.html#temfpy.schmidt_utils.StoppingCondition.degeneracy_tol"><code class="docutils literal notranslate"><span class="pre">StoppingCondition.degeneracy_tol</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/schmidt_utils.html#temfpy.schmidt_utils.StoppingCondition.__call__"><code class="docutils literal notranslate"><span class="pre">StoppingCondition.__call__()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/schmidt_utils.html#temfpy.schmidt_utils.StoppingCondition.truncate"><code class="docutils literal notranslate"><span class="pre">StoppingCondition.truncate()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/schmidt_utils.html#temfpy.schmidt_utils.lowest_sums"><code class="docutils literal notranslate"><span class="pre">lowest_sums()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/utils.html">utils</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../reference/utils.html#temfpy.utils.HT"><code class="docutils literal notranslate"><span class="pre">HT()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/utils.html#temfpy.utils.n_slice"><code class="docutils literal notranslate"><span class="pre">n_slice()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/utils.html#temfpy.utils.block_svd"><code class="docutils literal notranslate"><span class="pre">block_svd()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/utils.html#temfpy.utils.normalize_SV"><code class="docutils literal notranslate"><span class="pre">normalize_SV()</span></code></a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">TeMFpy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">temfpy.pfaffian</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for temfpy.pfaffian</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (C) TeMFPy Developers, MIT license</span>
<span class="sa">r</span><span class="sd">&quot;&quot;&quot;Tools for converting Pfaffian wave functions into matrix product states (MPS).</span>

<span class="sd">.. _nambu:</span>

<span class="sd">Representing Nambu correlation matrices</span>
<span class="sd">---------------------------------------</span>

<span class="sd">The input of the algorithm is the Nambu correlation matrix that contains</span>
<span class="sd">:math:`\langle cc \rangle` and :math:`\langle c^\dagger c\dagger \rangle` correlators</span>
<span class="sd">in addition to the standard :math:`\langle c^\dagger c \rangle` ones.</span>
<span class="sd">Such a correlation matrix may be specified in two different bases:</span>

<span class="sd">* In the standard **complex-fermion** basis, the Nambu correlation matrix</span>
<span class="sd">  is listed as 2×2 blocks ``C[2*i : 2*i+2, 2*j : 2*j+2]`` of </span>

<span class="sd">  .. math::</span>
<span class="sd">  </span>
<span class="sd">        \begin{pmatrix}</span>
<span class="sd">            \langle c_j^\dagger c_i         \rangle &amp; \langle c_j c_i         \rangle \\</span>
<span class="sd">            \langle c_j^\dagger c_i^\dagger \rangle &amp; \langle c_j c_i^\dagger \rangle</span>
<span class="sd">        \end{pmatrix},</span>

<span class="sd">  where :math:`c_i` and :math:`c_i^\dagger` are the standard fermion</span>
<span class="sd">  annihilation and creation operators on site :math:`0\le i &lt; L.`</span>

<span class="sd">* We can also use the **Majorana** basis, defined by</span>

<span class="sd">  .. math::</span>

<span class="sd">        \gamma_{2n} &amp;= (c^\dagger_n + c_n) / \sqrt{2},\\</span>
<span class="sd">        \gamma_{2n+1} &amp;= i(c^\dagger_n - c_n) / \sqrt{2}</span>

<span class="sd">  for all :math:`0\le n &lt; L`. In this basis, the correlation matrix is specified</span>
<span class="sd">  as the matrix :math:`\langle \gamma_j\gamma_i \rangle.`</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Type</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">partial</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy.linalg</span><span class="w"> </span><span class="kn">import</span> <span class="n">eigh</span><span class="p">,</span> <span class="n">inv</span><span class="p">,</span> <span class="n">svd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tenpy.linalg.np_conserved</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">npc</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tenpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">networks</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pfapack.ctypes</span><span class="w"> </span><span class="kn">import</span> <span class="n">pfaffian</span> <span class="k">as</span> <span class="n">cpf</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">HT</span><span class="p">,</span> <span class="n">block_svd</span><span class="p">,</span> <span class="n">normalize_SV</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.testing</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">assert_allclose</span><span class="p">,</span>
    <span class="n">assert_array_less</span><span class="p">,</span>
    <span class="n">check_schmidt_decomposition</span><span class="p">,</span>
    <span class="n">_DIAG_TOL</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.schmidt_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">lowest_sums</span><span class="p">,</span> <span class="n">StoppingCondition</span><span class="p">,</span> <span class="n">to_stopping_condition</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">iMPS</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="n">fermion_site</span> <span class="o">=</span> <span class="n">networks</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">FermionSite</span><span class="p">(</span><span class="n">conserve</span><span class="o">=</span><span class="s2">&quot;parity&quot;</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;Lattice site prototype for the parity-conserving fermion MPS.&quot;&quot;&quot;</span>
<span class="n">fermion_leg</span> <span class="o">=</span> <span class="n">fermion_site</span><span class="o">.</span><span class="n">leg</span>
<span class="sd">&quot;&quot;&quot;:class:`~tenpy.linalg.charges.LegCharge` for the single-site Hilbert space</span>
<span class="sd">of the parity-conserving fermion MPS.&quot;&quot;&quot;</span>
<span class="n">chinfo</span> <span class="o">=</span> <span class="n">fermion_leg</span><span class="o">.</span><span class="n">chinfo</span>
<span class="sd">&quot;&quot;&quot;:class:`~tenpy.linalg.charges.ChargeInfo` for fermion parity conservation.&quot;&quot;&quot;</span>

<span class="c1">#### BASIS TRANSFORMATIONS BETWEEN COMPLEX FERMION AND MAJORANA BASIS ####</span>
<span class="c1">#### ---------------------------------------------------------------- ####</span>


<div class="viewcode-block" id="vector_C2M">
<a class="viewcode-back" href="../../reference/pfaffian.html#temfpy.pfaffian.vector_C2M">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">vector_C2M</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Converts mode vectors from complex-fermion to Majorana basis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v:</span>
<span class="sd">        A vector or a multidimensional array of vectors in the complex-fermion basis.</span>

<span class="sd">        In the latter case, the &quot;site&quot; dimension is expected as first</span>
<span class="sd">        (i.e. several vectors should be supplied as columns of a matrix).</span>

<span class="sd">        The complex-fermion basis should be listed in the order</span>
<span class="sd">        :math:`c^\dagger_1, c_1, \dots, c^\dagger_L, c_L`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        The given vectors in the Majorana basis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Got vector(s) of odd size (cannot be Nambu)&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="c1"># unitary acts on second index of the reshaped v</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">]])</span> <span class="o">/</span> <span class="mi">2</span><span class="o">**</span><span class="mf">0.5</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;xa...,ca-&gt;xc...&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">v</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span></div>



<div class="viewcode-block" id="vector_M2C">
<a class="viewcode-back" href="../../reference/pfaffian.html#temfpy.pfaffian.vector_M2C">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">vector_M2C</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Converts mode vectors from Majorana to complex-fermion basis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v:</span>
<span class="sd">        A vector or a multidimensional array of vectors in the Majorana basis.</span>

<span class="sd">        In the latter case, the &quot;site&quot; dimension is expected as first</span>
<span class="sd">        (i.e. several vectors should be supplied as columns of a matrix).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        The given vectors in the complex-fermion basis.</span>

<span class="sd">        The complex-fermion basis is listed in the order</span>
<span class="sd">        :math:`c^\dagger_1, c_1, \dots, c^\dagger_L, c_L`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Got vector(s) of odd size (cannot be Nambu)&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="c1"># unitary acts on second index of the reshaped v</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="n">j</span><span class="p">]])</span> <span class="o">/</span> <span class="mi">2</span><span class="o">**</span><span class="mf">0.5</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;xa...,ca-&gt;xc...&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">v</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span></div>



<div class="viewcode-block" id="matrix_C2M">
<a class="viewcode-back" href="../../reference/pfaffian.html#temfpy.pfaffian.matrix_C2M">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">matrix_C2M</span><span class="p">(</span><span class="n">H</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Converts Hamiltonian or correlation matrices</span>
<span class="sd">    from complex-fermion to Majorana basis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    H:</span>
<span class="sd">        A matrix in the complex-fermion basis.</span>

<span class="sd">        See the module documentation for the expected layout.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        The given matrix in the Majorana basis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">assert</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Got a matrix with odd side length (cannot be Nambu)&quot;</span>
    <span class="k">assert</span> <span class="n">m</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Got a matrix with odd side length (cannot be Nambu)&quot;</span>
    <span class="n">n</span> <span class="o">//=</span> <span class="mi">2</span>
    <span class="n">m</span> <span class="o">//=</span> <span class="mi">2</span>

    <span class="c1"># isolate site and Nambu indices</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">]])</span> <span class="o">/</span> <span class="mi">2</span><span class="o">**</span><span class="mf">0.5</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;xayb,ca,db-&gt;xcyd&quot;</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">M</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">H</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span></div>



<div class="viewcode-block" id="matrix_M2C">
<a class="viewcode-back" href="../../reference/pfaffian.html#temfpy.pfaffian.matrix_M2C">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">matrix_M2C</span><span class="p">(</span><span class="n">H</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Converts Hamiltonian or correlation matrices</span>
<span class="sd">    from Majorana to complex-fermion basis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    H:</span>
<span class="sd">        A matrix in the Majorana basis.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        The given matrix in the complex-fermion basis.</span>

<span class="sd">        See the module documentation for the detailed layout.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">assert</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Got a matrix with odd side length (cannot be Nambu)&quot;</span>
    <span class="k">assert</span> <span class="n">m</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Got a matrix with odd side length (cannot be Nambu)&quot;</span>
    <span class="n">n</span> <span class="o">//=</span> <span class="mi">2</span>
    <span class="n">m</span> <span class="o">//=</span> <span class="mi">2</span>

    <span class="c1"># isolate site and Nambu indices</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="n">j</span><span class="p">]])</span> <span class="o">/</span> <span class="mi">2</span><span class="o">**</span><span class="mf">0.5</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;xayb,ca,db-&gt;xcyd&quot;</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">M</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">H</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span></div>



<span class="c1">#### UTILITIES FOR NAMBU CORRELATION MATRICES ####</span>
<span class="c1">#### ---------------------------------------- ####</span>
<div class="viewcode-block" id="assert_nambu">
<a class="viewcode-back" href="../../reference/pfaffian.html#temfpy.pfaffian.assert_nambu">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">assert_nambu</span><span class="p">(</span>
    <span class="n">C</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">basis</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">offset</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="n">rtol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">atol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Indicates if a matrix is not Nambu symmetric.</span>
<span class="sd">    </span>
<span class="sd">    In Majorana basis, Nambu symmetry requires that the matrix be imaginary</span>
<span class="sd">    and antisymmetric, except for a constant ``offset / 2`` on the diagonal.</span>

<span class="sd">    In complex-fermion basis, the matrix can be split into blocks</span>
<span class="sd">    by creation and annihilation operators, e.g.,</span>

<span class="sd">    .. math::</span>

<span class="sd">        C = \begin{pmatrix}</span>
<span class="sd">            \langle c_j^\dagger c_i         \rangle &amp; \langle c_j c_i         \rangle \\</span>
<span class="sd">            \langle c_j^\dagger c_i^\dagger \rangle &amp; \langle c_j c_i^\dagger \rangle</span>
<span class="sd">        \end{pmatrix} </span>
<span class="sd">        =: \begin{pmatrix} C_{11} &amp; C_{12} \\ C_{21} &amp; C_{22} \end{pmatrix},</span>

<span class="sd">    which must satisfy </span>

<span class="sd">    .. math::</span>

<span class="sd">        C_{11} + C_{22}^* &amp;= \texttt{offset}\times\mathbb{I} \\</span>
<span class="sd">        C_{12} &amp;= -C_{21}^*.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    C:</span>
<span class="sd">        Nambu matrix to be checked.</span>
<span class="sd">    basis:</span>
<span class="sd">        Whether the matrix is supplied in</span>
<span class="sd">        Majorana (``&quot;M&quot;``) or complex-fermion (``&quot;C&quot;``) basis.</span>

<span class="sd">        If unspecified, only checks if the matrix is Hermitian.</span>
<span class="sd">    offset:</span>
<span class="sd">        Constant diagonal offset.</span>

<span class="sd">        Should be 0 for Hamiltonians and 1 for correlation matrices.</span>
<span class="sd">    name:</span>
<span class="sd">        Type of matrix (e.g. ``&quot;Hamiltonian&quot;``)</span>
<span class="sd">    rtol:</span>
<span class="sd">        Relative tolerance for matrix-element checks.</span>
<span class="sd">    atol:</span>
<span class="sd">        Absolute tolerance for matrix-element checks.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Regularised Nambu matrix.</span>

<span class="sd">        - Skew-Hermitian component is removed.</span>
<span class="sd">        - In the Majorana basis, small real-part deviations are deleted.</span>
<span class="sd">        - In the complex-fermion basis, small imaginary parts are pruned</span>
<span class="sd">          if the matrix is almost real.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    AssertionError | testing.ComparisonWarning</span>
<span class="sd">        If ``C`` is not Hermitian or Nambu symmetric up to the given tolerance.</span>
<span class="sd">        </span>
<span class="sd">        Whether an exception or a warning is raised is determined by</span>
<span class="sd">        :data:`.testing.TEST_ACTION`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># check shape</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">assert</span> <span class="n">n</span> <span class="o">==</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Got non-square </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">assert</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> with odd side length (cannot be Nambu)&quot;</span>
    <span class="n">n</span> <span class="o">//=</span> <span class="mi">2</span>

    <span class="c1"># Hermiticity</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">)</span>
    <span class="n">assert_allclose</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">HT</span><span class="p">(</span><span class="n">C</span><span class="p">),</span> <span class="o">**</span><span class="n">tol</span><span class="p">,</span> <span class="n">err_msg</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> is not Hermitian&quot;</span><span class="p">)</span>
    <span class="n">C</span> <span class="o">=</span> <span class="p">(</span><span class="n">C</span> <span class="o">+</span> <span class="n">HT</span><span class="p">(</span><span class="n">C</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="c1"># check Nambu symmetry of result</span>
    <span class="k">if</span> <span class="n">basis</span> <span class="o">==</span> <span class="s2">&quot;M&quot;</span><span class="p">:</span>
        <span class="n">err</span> <span class="o">=</span> <span class="s2">&quot;Unexpected real parts in Majorana basis&quot;</span>
        <span class="n">real</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">offset</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">assert_allclose</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span> <span class="o">**</span><span class="n">tol</span><span class="p">,</span> <span class="n">err_msg</span><span class="o">=</span><span class="n">err</span><span class="p">)</span>
        <span class="n">C</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">real</span>
    <span class="k">elif</span> <span class="n">basis</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span><span class="p">:</span>
        <span class="n">err</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span><span class="si">}</span><span class="s2"> is not Nambu symmetric&quot;</span>
        <span class="n">assert_allclose</span><span class="p">(</span>
            <span class="n">C</span><span class="p">[::</span><span class="mi">2</span><span class="p">,</span> <span class="p">::</span><span class="mi">2</span><span class="p">],</span> <span class="n">offset</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="o">**</span><span class="n">tol</span><span class="p">,</span> <span class="n">err_msg</span><span class="o">=</span><span class="n">err</span>
        <span class="p">)</span>
        <span class="n">assert_allclose</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="p">::</span><span class="mi">2</span><span class="p">],</span> <span class="o">-</span><span class="n">C</span><span class="p">[::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="o">**</span><span class="n">tol</span><span class="p">,</span> <span class="n">err_msg</span><span class="o">=</span><span class="n">err</span><span class="p">)</span>
        <span class="c1"># often the correlation matrix in complex-fermion operators is real</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">tol</span><span class="p">):</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">real</span>
    <span class="k">elif</span> <span class="n">basis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># if None, we don&#39;t check for Nambu</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid `basis` &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">basis</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">C</span></div>



<span class="n">assert_nambu_hamiltonian</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">assert_nambu</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Hamiltonian&quot;</span><span class="p">)</span>
<span class="n">assert_nambu_hamiltonian</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Indicates if a Hamiltonian is not Nambu symmetric.</span>

<span class="s2">See :func:`assert_nambu` for details. (Arguments ``offset`` and ``name`` are fixed.)&quot;&quot;&quot;</span>

<span class="n">assert_nambu_correlation</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">assert_nambu</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;correlation matrix&quot;</span><span class="p">)</span>
<span class="n">assert_nambu_correlation</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Indicates if a correlation matrix is not Nambu symmetric.</span>

<span class="s2">See :func:`assert_nambu` for details. (Arguments ``offset`` and ``name`` are fixed.)&quot;&quot;&quot;</span>


<div class="viewcode-block" id="correlation_matrix">
<a class="viewcode-back" href="../../reference/pfaffian.html#temfpy.pfaffian.correlation_matrix">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">correlation_matrix</span><span class="p">(</span>
    <span class="n">H</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">basis</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">rtol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-10</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Ground-state correlation matrix of a mean-field Nambu Hamiltonian.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    H:</span>
<span class="sd">        Real-space Nambu Hamiltonian.</span>
<span class="sd">         </span>
<span class="sd">        If ``basis`` is given, it must be in the basis</span>
<span class="sd">        indicated by its first character.</span>
<span class="sd">    basis:</span>
<span class="sd">        Basis used by the input and the output.</span>

<span class="sd">        If specified, it is a string of the form ``&quot;X-&gt;Y&quot;``,</span>
<span class="sd">        where the characters ``X`` and ``Y`` must be M or C:</span>
<span class="sd">        </span>
<span class="sd">        * ``X`` controls whether the Hamiltonian is given</span>
<span class="sd">          in the Majorana or the complex-fermion basis.</span>
<span class="sd">        * ``Y`` controls whether the correlation matrix is returned</span>
<span class="sd">          in the Majorana or the complex-fermion basis.</span>

<span class="sd">        If not specified, the output is returned in the same basis as the input,</span>
<span class="sd">        without testing for Nambu symmetry.</span>
<span class="sd">    rtol:</span>
<span class="sd">        Relative tolerance for eigenvalue and matrix-element checks.</span>
<span class="sd">    atol:</span>
<span class="sd">        Absolute tolerance for eigenvalue and matrix-element checks.</span>

<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        The correlation matrix C in the format indicated by</span>
<span class="sd">        the last character of ``mode``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In Majorana mode ``&quot;M-&gt;*&quot;``, the Hamiltonian is expected as the</span>
<span class="sd">    array of coefficients of :math:`\gamma_i \gamma_j`.</span>

<span class="sd">    In complex-fermion mode ``&quot;C-&gt;*&quot;``, the Hamiltonian is expected as </span>
<span class="sd">    2×2 blocks of coefficients of</span>

<span class="sd">    .. math::</span>
<span class="sd">    </span>
<span class="sd">        \begin{pmatrix}</span>
<span class="sd">            c_i^\dagger c_j &amp; c_i^\dagger c_j^\dagger \\</span>
<span class="sd">            c_i         c_j &amp; c_i         c_j^\dagger</span>
<span class="sd">        \end{pmatrix}.</span>

<span class="sd">    For the format of the correlation matrices, see :ref:`nambu`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># check argument `basis`</span>
    <span class="n">basis_error</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Invalid basis spec </span><span class="si">{</span><span class="n">basis</span><span class="si">!r}</span><span class="s2">, should be of form &#39;[MC]-&gt;[MC]&#39;&quot;</span>
    <span class="k">assert</span> <span class="n">basis</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;M-&gt;M&quot;</span><span class="p">,</span> <span class="s2">&quot;M-&gt;C&quot;</span><span class="p">,</span> <span class="s2">&quot;C-&gt;M&quot;</span><span class="p">,</span> <span class="s2">&quot;C-&gt;C&quot;</span><span class="p">],</span> <span class="n">basis_error</span>

    <span class="n">tol</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">)</span>

    <span class="c1"># check Hamiltonian</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">assert_nambu_hamiltonian</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">basis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">basis</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">tol</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">H</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="c1"># diagonalise</span>
    <span class="n">e</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">eigh</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>

    <span class="c1"># check that spectrum is symmetric</span>
    <span class="n">assert_allclose</span><span class="p">(</span><span class="n">e</span> <span class="o">+</span> <span class="n">e</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">tol</span><span class="p">)</span>

    <span class="c1"># check that there are no almost-zero eigenvalues</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">atol</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="s2">&quot;Some energy eigenvalues are zero. You need to construct</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;your own correlation matrix!</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Middle 10 eigenvalues:</span><span class="se">\n</span><span class="si">{</span><span class="n">e</span><span class="p">[</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="kc">None</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Filter negative eigenvalues</span>
    <span class="n">assert_array_less</span><span class="p">(</span><span class="n">e</span><span class="p">[:</span><span class="n">n</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Lower half of eigenvalues is not all negative&quot;</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span> <span class="p">:</span><span class="n">n</span><span class="p">]</span>

    <span class="c1"># basis conversions if needed</span>
    <span class="k">if</span> <span class="n">basis</span> <span class="o">==</span> <span class="s2">&quot;C-&gt;M&quot;</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">vector_C2M</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">basis</span> <span class="o">==</span> <span class="s2">&quot;M-&gt;C&quot;</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">vector_M2C</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="n">C</span> <span class="o">=</span> <span class="n">v</span> <span class="o">@</span> <span class="n">HT</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="c1"># check Nambu symmetry of result</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">assert_nambu_correlation</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">basis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">basis</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="o">**</span><span class="n">tol</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">C</span></div>



<div class="viewcode-block" id="parity">
<a class="viewcode-back" href="../../reference/pfaffian.html#temfpy.pfaffian.parity">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">parity</span><span class="p">(</span><span class="n">V</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-12</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Fermion parity of a Boguliubov vacuum.</span>

<span class="sd">    The calculation is based on the Bloch-Messiah decomposition.</span>
<span class="sd">    If the Boguliubov operators :math:`\gamma` that define the vacuum</span>
<span class="sd">    are related to the standard fermion operators :math:`c` by</span>

<span class="sd">    .. math::</span>

<span class="sd">        (\gamma^\dagger, \gamma) = (c^\dagger, c) \begin{pmatrix}</span>
<span class="sd">            U &amp; V^* \\ V &amp; U^*</span>
<span class="sd">        \end{pmatrix},</span>

<span class="sd">    the singular values of the matrix :math:`V` (and also :math:`V^*`) are</span>
<span class="sd">    (in decreasing order)</span>
<span class="sd">    :math:`1, \dots, 1, \sigma_1, \sigma_1, \dots, \sigma_n, \sigma_n, 0, \dots, 0`.</span>
<span class="sd">    The parity of the vacuum is that of the number of completely filled modes</span>
<span class="sd">    (i.e., singular values 1).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        V:</span>
<span class="sd">            submatrix of Nambu mode unitary that maps :math:`c` to</span>
<span class="sd">            :math:`\gamma^\dagger` (or :math:`c^\dagger` to :math:`\gamma`).</span>
<span class="sd">        tol:</span>
<span class="sd">            tolerance for considering two numbers equal</span>
<span class="sd">            (only needed for edge cases of 1 and 2 modes)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        parity as 0 (even) or 1 (odd)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">tol</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">V</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">tol</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Invalid 1x1 V&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">compute_uv</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># instead of isolating the precisely 1 singular values,</span>
            <span class="c1"># note that SVs between 0 and 1 come in pairs,</span>
            <span class="c1"># so it is enough to find the largest gap between them</span>
            <span class="c1"># the parity of SVs above that gap is the same as the 1s</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span>  <span class="c1"># NB arrays are zero indexed</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># usual autodetection fails (there&#39;s only 1 difference)</span>
            <span class="c1"># there is either a 1 and a 0 SV (-&gt; parity odd)</span>
            <span class="c1"># or two equal ones (-&gt; parity even)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">rtol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">tol</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rtol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">tol</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid 2x2 V&quot;</span><span class="p">)</span></div>



<span class="c1">#### SCHMIDT ORBITALS ####</span>
<span class="c1">#### ---------------- ####</span>
<div class="viewcode-block" id="SchmidtModes">
<a class="viewcode-back" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes">[docs]</a>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SchmidtModes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Boguliubov excitations that generate the Schmidt vectors</span>
<span class="sd">    of a Nambu mean-field state.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nL</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Size of the left half of the system.&quot;&quot;&quot;</span>
    <span class="n">nR</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Size of the right half of the system.&quot;&quot;&quot;</span>
    <span class="n">e</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;array (:attr:`n_entangled`,) --</span>
<span class="sd">    Entangled eigenvalues :math:`0 &lt; \lambda\le 1/2` of the</span>
<span class="sd">    diagonal blocks of the correlation matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vL</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;array (2\ :attr:`nL`, 2\ :attr:`nL`) --</span>
<span class="sd">    Eigenvectors of the left-left block of the correlation matrix</span>
<span class="sd">    in the complex-fermion basis, if computed.</span>

<span class="sd">    The eigenvectors are the columns of the matrix in the order of eigenvalues</span>

<span class="sd">    - :math:`0\le \lambda\le 1/2` in increasing order</span>
<span class="sd">    - :math:`1\ge \lambda\ge 1/2` in decreasing order,</span>

<span class="sd">    i.e. the entangled modes are ``vL[:, nL-n_entangled : nL]`` (eigenvalues: :attr:`e`)</span>
<span class="sd">    and ``vL[:, -n_entangled:]`` (eigenvalues: ``1-e``).</span>
<span class="sd">    </span>
<span class="sd">    The eigenvectors obey the Nambu symmetry:</span>

<span class="sd">        vL[::2, nL:] == vL[1::2, :nL].conj()</span>
<span class="sd">        vL[1::2, nL:] == vL[::2, :nL].conj()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vR</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;array (2\ :attr:`nR`, 2\ :attr:`nR`) --</span>
<span class="sd">    Eigenvectors of the right-right block of the correlation matrix</span>
<span class="sd">    in the complex-fermion basis, if computed.</span>

<span class="sd">    The eigenvectors are the columns of the matrix in the order of eigenvalues</span>

<span class="sd">    - :math:`1/2\ge \lambda\ge 0` in decreasing order</span>
<span class="sd">    - :math:`1/2\le \lambda\le 1` in increasing order,</span>

<span class="sd">    i.e. the entangled modes are ``vR[:, :n_entangled]`` (eigenvalues: ``e[::-1]``)</span>
<span class="sd">    and ``vR[:, nR : nR+n_entangled]`` (eigenvalues: ``1-e[::-1]``).</span>

<span class="sd">    They obey the Nambu symmetry::</span>

<span class="sd">        vR[::2, nR:] == vR[1::2, :nR].conj()</span>
<span class="sd">        vR[1::2, nR:] == vR[::2, :nR].conj()</span>

<span class="sd">    If both :attr:`vL` and :attr:`vR` are known, their entangled components</span>
<span class="sd">    the left-right block of the Hamiltonian::</span>
<span class="sd">    </span>
<span class="sd">        S = sqrt(e * (1-e))</span>
<span class="sd">        S = concatenate((S, -S))</span>
<span class="sd">        vL_entangled.T.conj() @ C[:2*nL, 2*nL:] @ vR_entangled[:, ::-1] == diag(S)</span>

<span class="sd">    However, to better handle fermion anticommutation, the sign of :attr:`vR` is</span>
<span class="sd">    reversed if the left Boguliubov vacuum is parity odd.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pL</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;0 or 1 --</span>
<span class="sd">    Parity of the Boguliubov vacuum that annihilates the operators</span>
<span class="sd">    defined by eigenvectors ``vL[:, nL:]``, if computed.&quot;&quot;&quot;</span>
    <span class="n">pR</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;0 or 1 --</span>
<span class="sd">    Parity of the Boguliubov vacuum that annihilates the operators</span>
<span class="sd">    defined by eigenvectors ``vR[:, nR:]``, if computed.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="SchmidtModes.parity">
<a class="viewcode-back" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.parity">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">parity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;T&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parity of the Boguliubov vacuum on the specified half of the system.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        which:</span>
<span class="sd">            Either &quot;L&quot; for left or &quot;R&quot; for right side</span>
<span class="sd">            or &quot;T&quot; (default) for the overall parity of the state.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            :attr:`pL`, :attr:`pR`, or the overall parity, depending on ``which``</span>
<span class="sd">            or :obj:`None` if the requested parity is unknown.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">which_</span> <span class="o">=</span> <span class="n">which</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">which_</span> <span class="o">==</span> <span class="s2">&quot;L&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pL</span>
        <span class="k">elif</span> <span class="n">which_</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pR</span>
        <span class="k">elif</span> <span class="n">which_</span> <span class="o">==</span> <span class="s2">&quot;T&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pL</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pR</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pL</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pR</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`which` must start with L, R, or T, got &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">which</span><span class="p">))</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vL</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">pL</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;`pL` must be specified with `vL`&quot;</span>
            <span class="k">assert</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nL</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vL</span><span class="p">),</span> <span class="s2">&quot;`nL` must match the size of `vL`&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vR</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">pR</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;`pR` must be specified with `vR`&quot;</span>
            <span class="k">assert</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nR</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vR</span><span class="p">),</span> <span class="s2">&quot;`nR` must match the size of `vR`&quot;</span>
        <span class="n">err</span> <span class="o">=</span> <span class="s2">&quot;Must specify at least one of `vL`, `vR`&quot;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vL</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vR</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">),</span> <span class="n">err</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">n_entangled</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of entangled orbitals.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">e</span><span class="o">.</span><span class="n">size</span>

<div class="viewcode-block" id="SchmidtModes.size">
<a class="viewcode-back" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.size">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;T&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Size of the specified half or the whole of the system.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        which:</span>
<span class="sd">            Either &quot;L&quot; for left or &quot;R&quot; for right side</span>
<span class="sd">            or &quot;T&quot; (default) for total size.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            :attr:`nL`, :attr:`nR`, or their sum, depending on ``which``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">which_</span> <span class="o">=</span> <span class="n">which</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">which_</span> <span class="o">==</span> <span class="s2">&quot;L&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nL</span>
        <span class="k">elif</span> <span class="n">which_</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nR</span>
        <span class="k">elif</span> <span class="n">which_</span> <span class="o">==</span> <span class="s2">&quot;T&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nL</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nR</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`which` must start with L, R, or T, got &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">which</span><span class="p">))</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">vL_entangled</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Entangled left Schmidt mode orbitals, if computed.&quot;&quot;&quot;</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nL</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_entangled</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nL</span><span class="p">)</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">ix</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nL</span><span class="p">))</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vL</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">vL</span><span class="p">[:,</span> <span class="n">ix</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">vR_entangled</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Entangled right Schmidt mode orbitals, if computed.&quot;&quot;&quot;</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_entangled</span><span class="p">)</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">ix</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nR</span><span class="p">))</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vR</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">vR</span><span class="p">[:,</span> <span class="n">ix</span><span class="p">]</span>

<div class="viewcode-block" id="SchmidtModes.mode_vectors">
<a class="viewcode-back" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.mode_vectors">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mode_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">entangled</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the Schmidt mode orbitals on the specified side.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        which:</span>
<span class="sd">            Either &quot;L&quot; for left or &quot;R&quot; for right side.</span>
<span class="sd">        entangled:</span>
<span class="sd">            Whether to return the entangled (:obj:`True`) or</span>
<span class="sd">            all (:obj:`False`, default) eigenvectors.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            Either :attr:`vL` or :attr:`vR`, depending on ``which``,</span>
<span class="sd">            truncated to entangled modes if ``entangled``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">which_</span> <span class="o">=</span> <span class="n">which</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">which_</span> <span class="o">==</span> <span class="s2">&quot;L&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vL_entangled</span> <span class="k">if</span> <span class="n">entangled</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">vL</span>
        <span class="k">elif</span> <span class="n">which_</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vR_entangled</span> <span class="k">if</span> <span class="n">entangled</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">vR</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`which` must start with L or R, got &quot;</span> <span class="o">+</span> <span class="n">which</span><span class="p">)</span></div>


<div class="viewcode-block" id="SchmidtModes.eigenvalues">
<a class="viewcode-back" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.eigenvalues">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">eigenvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">entangled</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the Schmidt mode eigenvalues on the specified side.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        which:</span>
<span class="sd">            Either &quot;L&quot; for left or &quot;R&quot; for right side.</span>
<span class="sd">        entangled:</span>
<span class="sd">            Whether to return the entangled (:obj:`True`) or</span>
<span class="sd">            all (:obj:`False`, default) eigenvalues.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            The eigenvalues corresponding to :meth:`mode_vectors`</span>
<span class="sd">            with the same parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">which_</span> <span class="o">=</span> <span class="n">which</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">which_</span> <span class="o">==</span> <span class="s2">&quot;L&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vL</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">e</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">entangled</span><span class="p">:</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nL</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_entangled</span><span class="p">),</span> <span class="n">e</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">which_</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vR</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">e</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">entangled</span><span class="p">:</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nR</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_entangled</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`which` must start with L or R, got &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">which</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">e</span><span class="p">))</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">singular_values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Singular values of the offdiagonal correlation matrix blocks.</span>

<span class="sd">        If :attr:`vL_entangled` and :attr:`vR_entangled` are both known, satisfies</span>

<span class="sd">        .. code::</span>

<span class="sd">            C_LR == vL_entangled @ diag(S) @ vR_entangled[:, ::-1].T.conj()</span>

<span class="sd">        Otherwise, :obj:`None`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vL</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vR</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">SV</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">e</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">e</span><span class="p">))</span> <span class="o">**</span> <span class="mf">0.5</span>
        <span class="n">SV</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pL</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="o">+</span><span class="mi">1</span>  <span class="c1"># anticommutation sign</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">SV</span><span class="p">,</span> <span class="o">-</span><span class="n">SV</span><span class="p">))</span>  <span class="c1"># Nambu sign</span>

<div class="viewcode-block" id="SchmidtModes.from_correlation_matrix">
<a class="viewcode-back" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.from_correlation_matrix">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_correlation_matrix</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="s2">&quot;SchmidtModes&quot;</span><span class="p">],</span>
        <span class="n">C</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">trunc_par</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="n">StoppingCondition</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">basis</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">which</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;LR&quot;</span><span class="p">,</span>
        <span class="n">diag_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_DIAG_TOL</span><span class="p">,</span>
        <span class="n">total_parity</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;SchmidtModes&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Computes the :class:`~SchmidtModes` of a Nambu mean-field state</span>
<span class="sd">        with correlation matrix ``C`` for an entanglement cut between</span>
<span class="sd">        sites ``x-1`` and ``x`` (zero-indexed).</span>

<span class="sd">        We do this by diagonalising the left-left and right-right blocks of ``C``.</span>
<span class="sd">        The eigenvectors give the Schmidt modes, the eigenvalues their</span>
<span class="sd">        relative weight in the entangled mode. We only treat modes with</span>
<span class="sd">        eigenvalues away from 0 or 1 by at least `cutoff` as entangled.</span>

<span class="sd">        We enforce Nambu symmetry by redefining the eigenvectors for</span>
<span class="sd">        eigenvalues above 1/2 in terms of the other half.</span>

<span class="sd">        If both left and right modes are computed, the entangled ones are</span>
<span class="sd">        paired up by ensuring that the eigenvalues sum to 1, and that they</span>
<span class="sd">        SVD-diagonalise the top right block C_LR and their signs are fixed</span>
<span class="sd">        so as to handle anticommutation signs optimally.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        C:</span>
<span class="sd">            The correlation matrix.</span>
<span class="sd">        x:</span>
<span class="sd">            Position of the entanglement cut.</span>
<span class="sd">        trunc_par:</span>
<span class="sd">            Which Schmidt modes should be kept as entangled.</span>

<span class="sd">            Must be either a :class:`~temfpy.schmidt_utils.StoppingCondition` object</span>
<span class="sd">            or a dictionary with matching keys.</span>
<span class="sd">        basis:</span>
<span class="sd">            whether the correlation matrix is supplied in</span>
<span class="sd">            Majorana (``&quot;M&quot;``, default) or complex-fermion (``&quot;C&quot;``) basis.</span>
<span class="sd">        which:</span>
<span class="sd">            Whether to return Left and/or Right Schmidt modes.</span>
<span class="sd">            Must be a combination of ``&quot;L&quot;``, ``&quot;R&quot;``.</span>
<span class="sd">        diag_tol:</span>
<span class="sd">            If ``which==&quot;LR&quot;``, largest allowed offdiagonal matrix element in</span>
<span class="sd">            diagonalised / SVD correlation submatrices before an error is raised.</span>
<span class="sd">        total_parity:</span>
<span class="sd">            Used to infer the parity of the leading Schmidt state on both sides</span>
<span class="sd">            if Schmidt modes are only computed on one side.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        - If :attr:`trunc_par.svd_min` is not provided, a default of 1e-6</span>
<span class="sd">          (i.e., a truncation threshold of 1e-12) is used.</span>
<span class="sd">        - If :attr:`trunc_par.degeneracy_tol` is not provided, the degeneracy tolerance</span>
<span class="sd">          defaults to 1e-12.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trunc_par</span> <span class="o">=</span> <span class="n">to_stopping_condition</span><span class="p">(</span><span class="n">trunc_par</span><span class="p">)</span>
        <span class="n">cutoff</span> <span class="o">=</span> <span class="n">trunc_par</span><span class="o">.</span><span class="n">svd_min</span><span class="o">**</span><span class="mi">2</span>  <span class="c1"># eigenvalues -&gt; squared Schmidt values</span>
        <span class="n">deg_tol</span> <span class="o">=</span> <span class="n">trunc_par</span><span class="o">.</span><span class="n">degeneracy_tol</span>

        <span class="c1"># Internally, we always use the Majorana basis for diagonalisation</span>
        <span class="k">if</span> <span class="n">basis</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span><span class="p">:</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">matrix_C2M</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">basis</span> <span class="o">!=</span> <span class="s2">&quot;M&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Argument `basis` must be &#39;M&#39; or &#39;C&#39;, got </span><span class="si">{</span><span class="n">basis</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">assert_nambu_correlation</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s2">&quot;M&quot;</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>

        <span class="n">L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">L</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Invalid entanglement cut </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">, must be between 0 and </span><span class="si">{</span><span class="n">L</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">L</span> <span class="o">-</span> <span class="n">x</span>  <span class="c1"># size of right half</span>

        <span class="n">which</span> <span class="o">=</span> <span class="n">which</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="n">err</span> <span class="o">=</span> <span class="s2">&quot;`which` must specify at least one of (L)eft or (R)ight&quot;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="s2">&quot;L&quot;</span> <span class="ow">in</span> <span class="n">which</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s2">&quot;R&quot;</span> <span class="ow">in</span> <span class="n">which</span><span class="p">),</span> <span class="n">err</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">diag_nambu</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Args:</span>
<span class="sd">                c: diagonal submatrix of Majorana correlation matrix</span>

<span class="sd">            Returns: e, v, ke, kh</span>
<span class="sd">                e: eigenvalues of c in ascending order</span>
<span class="sd">                v: corresponding eigenvectors</span>
<span class="sd">                    for e[i] away from 1/2, v[:,i] = v[:,-i-1].conj()</span>
<span class="sd">                    for e[i] approximately 1/2, v[i] is purely real</span>
<span class="sd">                    (both are possible in Majorana basis)</span>
<span class="sd">                ke: half number of entangled modes</span>
<span class="sd">                    corresponding modes at e[n//2-ke : n//2+ke]</span>
<span class="sd">                kh: half number of approximately 1/2 eigenvalues</span>
<span class="sd">                    corresponding modes at e[n//2-kh : n//2+kh]</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># just need dummies for tuple unpacking</span>
                <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="mi">4</span>

            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="nb">float</span><span class="p">)</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">e</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

            <span class="n">e</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">eigh</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

            <span class="c1"># clip corr. matrix spectrum to [0,1]</span>
            <span class="n">err</span> <span class="o">=</span> <span class="s2">&quot;Invalid correlation matrix eigenvalues (should be between 0 and 1)&quot;</span>
            <span class="n">assert_array_less</span><span class="p">(</span><span class="o">-</span><span class="n">deg_tol</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">err_msg</span><span class="o">=</span><span class="n">err</span><span class="p">)</span>
            <span class="n">e</span><span class="p">[</span><span class="n">e</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">assert_array_less</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">deg_tol</span><span class="p">,</span> <span class="n">err_msg</span><span class="o">=</span><span class="n">err</span><span class="p">)</span>
            <span class="n">e</span><span class="p">[</span><span class="n">e</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="c1"># check symmetry of spectrum</span>
            <span class="n">err</span> <span class="o">=</span> <span class="s2">&quot;Eigenvalues break Nambu symmetry&quot;</span>
            <span class="n">assert_allclose</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">e</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">rtol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">deg_tol</span><span class="p">,</span> <span class="n">err_msg</span><span class="o">=</span><span class="n">err</span><span class="p">)</span>

            <span class="c1"># isolate 1/2 eigenvalues</span>
            <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.5</span> <span class="o">-</span> <span class="n">deg_tol</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">deg_tol</span><span class="p">])</span>
            <span class="n">kh</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">-</span> <span class="n">n</span>
            <span class="k">assert</span> <span class="n">x0</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="n">kh</span><span class="p">,</span> <span class="s2">&quot;1/2 eigenvalues asymmetrical in spectrum&quot;</span>

            <span class="c1"># make 1/2 modes real</span>
            <span class="k">if</span> <span class="n">kh</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">v</span><span class="p">[:,</span> <span class="n">x0</span><span class="p">:</span><span class="n">x1</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">v</span><span class="p">[:,</span> <span class="n">x0</span><span class="p">:</span><span class="n">x1</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">))</span>
                <span class="n">w</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>

                <span class="n">s_exp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">kh</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">kh</span><span class="p">)</span>
                <span class="n">err</span> <span class="o">=</span> <span class="s2">&quot;1/2 eigenvectors cannot be made real&quot;</span>
                <span class="n">assert_allclose</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s_exp</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">diag_tol</span><span class="p">,</span> <span class="n">err_msg</span><span class="o">=</span><span class="n">err</span><span class="p">)</span>

                <span class="n">v</span><span class="p">[:,</span> <span class="n">x0</span><span class="p">:</span><span class="n">x1</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span><span class="p">[:,</span> <span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">kh</span><span class="p">]</span>

            <span class="c1"># isolate entangled modes</span>
            <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">[</span><span class="n">cutoff</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">cutoff</span><span class="p">])</span>
            <span class="n">ke</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">-</span> <span class="n">n</span>
            <span class="k">assert</span> <span class="n">x0</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="n">ke</span><span class="p">,</span> <span class="s2">&quot;Entangled modes asymmetrical in spectrum&quot;</span>

            <span class="k">return</span> <span class="n">e</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">ke</span><span class="p">,</span> <span class="n">kh</span>

        <span class="n">eL</span><span class="p">,</span> <span class="n">vL</span><span class="p">,</span> <span class="n">keL</span><span class="p">,</span> <span class="n">khL</span> <span class="o">=</span> <span class="n">diag_nambu</span><span class="p">(</span><span class="n">C</span><span class="p">[:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;L&quot;</span> <span class="ow">in</span> <span class="n">which</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">eR</span><span class="p">,</span> <span class="n">vR</span><span class="p">,</span> <span class="n">keR</span><span class="p">,</span> <span class="n">khR</span> <span class="o">=</span> <span class="n">diag_nambu</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x</span> <span class="p">:,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span> <span class="p">:]</span> <span class="k">if</span> <span class="s2">&quot;R&quot;</span> <span class="ow">in</span> <span class="n">which</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">eL</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">eR</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>  <span class="c1"># should error earlier</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">keR</span>
                <span class="n">kh</span> <span class="o">=</span> <span class="n">khR</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">eR</span><span class="p">[</span><span class="n">y</span> <span class="o">-</span> <span class="n">k</span> <span class="p">:</span> <span class="n">y</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">eR</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">keL</span>
                <span class="n">kh</span> <span class="o">=</span> <span class="n">khL</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">eL</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="n">k</span> <span class="p">:</span> <span class="n">x</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># both &quot;L&quot; and &quot;R&quot; were done, need consistency checks</span>
                <span class="k">assert</span> <span class="n">keL</span> <span class="o">==</span> <span class="n">keR</span><span class="p">,</span> <span class="s2">&quot;Unequal number of entangled modes&quot;</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">keL</span>
                <span class="k">assert</span> <span class="n">khL</span> <span class="o">==</span> <span class="n">khR</span><span class="p">,</span> <span class="s2">&quot;Unequal number of 1/2 modes&quot;</span>
                <span class="n">kh</span> <span class="o">=</span> <span class="n">khL</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">eL</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="n">k</span> <span class="p">:</span> <span class="n">x</span><span class="p">]</span>

                <span class="n">err</span> <span class="o">=</span> <span class="s2">&quot;Eigenvalues of C_LL and C_RR do not match&quot;</span>
                <span class="n">assert_allclose</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">eR</span><span class="p">[</span><span class="n">y</span> <span class="o">-</span> <span class="n">k</span> <span class="p">:</span> <span class="n">y</span><span class="p">],</span> <span class="n">rtol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">deg_tol</span><span class="p">,</span> <span class="n">err_msg</span><span class="o">=</span><span class="n">err</span><span class="p">)</span>

                <span class="c1"># SVD 0 &lt; λ &lt; 1/2 modes</span>
                <span class="n">CLR</span> <span class="o">=</span> <span class="n">C</span><span class="p">[:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span> <span class="p">:]</span>
                <span class="n">vLE</span> <span class="o">=</span> <span class="n">vL</span><span class="p">[:,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">k</span> <span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="n">kh</span><span class="p">]</span>
                <span class="n">vRE</span> <span class="o">=</span> <span class="n">vR</span><span class="p">[:,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">kh</span> <span class="p">:</span> <span class="n">y</span> <span class="o">+</span> <span class="n">k</span><span class="p">][:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">block_svd</span><span class="p">(</span><span class="n">CLR</span><span class="p">,</span> <span class="n">vLE</span><span class="p">,</span> <span class="n">vRE</span><span class="p">,</span> <span class="n">eL</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="n">k</span> <span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="n">kh</span><span class="p">],</span> <span class="n">deg_tol</span><span class="p">,</span> <span class="n">diag_tol</span><span class="p">)</span>

                <span class="c1"># SVD 1/2 modes</span>
                <span class="c1"># keep both sides real, even though C_LR is pure imaginary</span>
                <span class="c1"># -&gt; SVD the imaginary part, so (w_Li)T C_LR w_Rj = i S δ_ij</span>
                <span class="n">ixL</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">kh</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">kh</span><span class="p">)</span>
                <span class="n">ixR</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">kh</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">kh</span><span class="p">)</span>
                <span class="n">s_block</span> <span class="o">=</span> <span class="n">vL</span><span class="p">[:,</span> <span class="n">ixL</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">CLR</span><span class="o">.</span><span class="n">imag</span> <span class="o">@</span> <span class="n">vR</span><span class="p">[:,</span> <span class="n">ixR</span><span class="p">]</span><span class="o">.</span><span class="n">real</span>
                <span class="n">U</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">Vh</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="n">s_block</span><span class="p">)</span>
                <span class="n">vL</span><span class="p">[:,</span> <span class="n">ixL</span><span class="p">]</span> <span class="o">=</span> <span class="n">vL</span><span class="p">[:,</span> <span class="n">ixL</span><span class="p">]</span> <span class="o">@</span> <span class="n">U</span>
                <span class="n">vR</span><span class="p">[:,</span> <span class="n">ixR</span><span class="p">]</span> <span class="o">=</span> <span class="n">vR</span><span class="p">[:,</span> <span class="n">ixR</span><span class="p">]</span> <span class="o">@</span> <span class="n">Vh</span><span class="o">.</span><span class="n">T</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> Schmidt modes found&quot;</span><span class="p">)</span>

        <span class="c1"># Fix Nambu symmetry, convert to complex-fermion basis, compute parity</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">nambu</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">kh</span><span class="p">,</span> <span class="n">LR</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">LR</span> <span class="o">==</span> <span class="s2">&quot;L&quot;</span><span class="p">:</span>
                <span class="c1"># Turn 1/2 eigenvectors from real to conjugate (Nambu) pairs</span>
                <span class="n">v</span><span class="p">[:,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">kh</span> <span class="p">:</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="p">[:,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">kh</span> <span class="p">:</span> <span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">v</span><span class="p">[:,</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">kh</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="o">**</span><span class="mf">0.5</span>
                <span class="c1"># Replace upper half with (Nambu) conjugates of the lower</span>
                <span class="n">v</span><span class="p">[:,</span> <span class="n">x</span><span class="p">:]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span> <span class="p">:</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">LR</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span><span class="p">:</span>
                <span class="n">v</span><span class="p">[:,</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">kh</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="p">[:,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">kh</span> <span class="p">:</span> <span class="n">x</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">v</span><span class="p">[:,</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">kh</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="o">**</span><span class="mf">0.5</span>
                <span class="c1"># Replace lower half with (Nambu) conjugates of the upper</span>
                <span class="n">v</span><span class="p">[:,</span> <span class="p">:</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span> <span class="n">x</span><span class="p">:]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>

            <span class="n">v</span> <span class="o">=</span> <span class="n">vector_M2C</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">parity</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="n">x</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">v</span><span class="p">,</span> <span class="n">p</span>

        <span class="k">if</span> <span class="s2">&quot;L&quot;</span> <span class="ow">in</span> <span class="n">which</span><span class="p">:</span>
            <span class="n">vL</span><span class="p">,</span> <span class="n">pL</span> <span class="o">=</span> <span class="n">nambu</span><span class="p">(</span><span class="n">vL</span><span class="p">,</span> <span class="n">kh</span><span class="p">,</span> <span class="s2">&quot;L&quot;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Parity of left Boguliubov vacuum: </span><span class="si">{</span><span class="n">pL</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;R&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">which</span> <span class="ow">and</span> <span class="n">total_parity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pR</span> <span class="o">=</span> <span class="p">(</span><span class="n">total_parity</span> <span class="o">+</span> <span class="n">pL</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Inferred parity of right Boguliubov vacuum: </span><span class="si">{</span><span class="n">pR</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;R&quot;</span> <span class="ow">in</span> <span class="n">which</span><span class="p">:</span>
            <span class="n">vR</span><span class="p">,</span> <span class="n">pR</span> <span class="o">=</span> <span class="n">nambu</span><span class="p">(</span><span class="n">vR</span><span class="p">,</span> <span class="n">kh</span><span class="p">,</span> <span class="s2">&quot;R&quot;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Parity of right Boguliubov vacuum: </span><span class="si">{</span><span class="n">pR</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;L&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">which</span> <span class="ow">and</span> <span class="n">total_parity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pL</span> <span class="o">=</span> <span class="p">(</span><span class="n">total_parity</span> <span class="o">+</span> <span class="n">pR</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Inferred parity of left Boguliubov vacuum: </span><span class="si">{</span><span class="n">pL</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># if parity of left vacuum is odd, need to flip the sign of all</span>
        <span class="c1"># right modes to compensate for commuting through it</span>
        <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;L&quot;</span> <span class="ow">in</span> <span class="n">which</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;R&quot;</span> <span class="ow">in</span> <span class="n">which</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">pL</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">vR</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">modes</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">e</span><span class="o">=</span><span class="n">e</span><span class="p">,</span> <span class="n">vL</span><span class="o">=</span><span class="n">vL</span><span class="p">,</span> <span class="n">vR</span><span class="o">=</span><span class="n">vR</span><span class="p">,</span> <span class="n">pL</span><span class="o">=</span><span class="n">pL</span><span class="p">,</span> <span class="n">pR</span><span class="o">=</span><span class="n">pR</span><span class="p">,</span> <span class="n">nL</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">nR</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
        <span class="n">check_schmidt_decomposition</span><span class="p">(</span><span class="n">modes</span><span class="p">,</span> <span class="n">matrix_M2C</span><span class="p">(</span><span class="n">C</span><span class="p">),</span> <span class="n">diag_tol</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">modes</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">e_ratio</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;:math:`\log((1-\lambda)/\lambda` for all eigenvalues in :attr:`e`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">e</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">e</span><span class="p">)</span>

<div class="viewcode-block" id="SchmidtModes.embed_subsets">
<a class="viewcode-back" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.embed_subsets">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">embed_subsets</span><span class="p">(</span>
        <span class="n">modes</span><span class="p">,</span> <span class="n">sets</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Given an array of :math:`\gamma^\dagger` excitations listed in order</span>
<span class="sd">        of the left singular vectors, generates the set of excitations on both sides.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sets: bool :class:`~np.ndarray` (n, :attr:`n_entangled`)</span>
<span class="sd">            Array of occupation numbers.</span>

<span class="sd">            Each row specifies one Schmidt state by listing whether each</span>
<span class="sd">            :math:`\gamma^\dagger` excitation is &quot;occupied&quot;.</span>

<span class="sd">            The order of the excitations is consistent with :attr:`vL`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        left_sets: bool :class:`~np.ndarray` (n, :attr:`n_entangled`) | :obj:`None`</span>
<span class="sd">            Occupation of excitations in the order of :attr:`vL`.</span>

<span class="sd">            Returned if :attr:`vL` is not :obj:`None`.</span>
<span class="sd">        right_sets: bool :class:`~np.ndarray` (n, :attr:`n_entangled`) | :obj:`None`</span>
<span class="sd">            Occupation of excitations in the order of :attr:`vR`.</span>

<span class="sd">            Returned if :attr:`vR` is not :obj:`None`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># `sets` is ordered correctly for left modes, must be reversed for right</span>
        <span class="n">left_sets</span> <span class="o">=</span> <span class="n">sets</span> <span class="k">if</span> <span class="n">modes</span><span class="o">.</span><span class="n">vL</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">right_sets</span> <span class="o">=</span> <span class="n">sets</span><span class="p">[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">modes</span><span class="o">.</span><span class="n">vR</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">left_sets</span><span class="p">,</span> <span class="n">right_sets</span></div>


<div class="viewcode-block" id="SchmidtModes.schmidt_values">
<a class="viewcode-back" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.schmidt_values">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">schmidt_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sets</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Schmidt values of the Schmidt vectors with given excitation numbers.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sets: bool :class:`~np.ndarray` (n, :attr:`n_entangled`)</span>
<span class="sd">            Array of occupation numbers.</span>

<span class="sd">            Each row specifies one Schmidt state by listing whether each</span>
<span class="sd">            :math:`\gamma^\dagger` excitation is &quot;occupied&quot;.</span>

<span class="sd">            The order of the excitations is consistent with :attr:`vL`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        λ: :class:`np.ndarray` (n,)</span>
<span class="sd">            Schmidt values corresponding to the input Schmidt vectors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">e</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span></div>
</div>



<span class="c1">#### SCHMIDT VECTORS ####</span>
<span class="c1">#### --------------- ####</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_parity_n_argsort</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sorts an array of integers first by parity, then value.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    idx: The indices that stable sort the flattened array.</span>
<span class="sd">    dict_n: Dict mapping values to slices in the sorted array.</span>
<span class="sd">    dict_p: Dict mapping parities to slices in the sorted array.&quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">idx</span><span class="p">,</span> <span class="n">_bunched_slices</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">_bunched_slices</span><span class="p">(</span><span class="n">x</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_bunched_slices</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">slice</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given a sorted array of integers, returns a dictionary that maps unique</span>
<span class="sd">    elements to the corresponding slice of the array.&quot;&quot;&quot;</span>
    <span class="p">(</span><span class="n">idx</span><span class="p">,)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)]))</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span> <span class="nb">slice</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)}</span>


<div class="viewcode-block" id="SchmidtVectors">
<a class="viewcode-back" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors">[docs]</a>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SchmidtVectors</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Schmidt vectors of a Nambu mean-field state.&quot;&quot;&quot;</span>

    <span class="n">modes</span><span class="p">:</span> <span class="n">SchmidtModes</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The Boguliubov excitations underlying the Schmidt vectors.&quot;&quot;&quot;</span>
    <span class="n">left_sets</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;bool (:attr:`n_schmidt`, :attr:`n_entangled`) --</span>
<span class="sd">    Left Schmidt vectors.</span>

<span class="sd">    Each row contains the occupation of all entangled :math:`\gamma_L^\dagger`</span>
<span class="sd">    excitations, described by ``vL[:, :n_entangled]``, in one left Schmidt vector,</span>
<span class="sd">    if :attr:`modes.vL` is not :obj:`None`.&quot;&quot;&quot;</span>
    <span class="n">right_sets</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;bool (:attr:`n_schmidt`, :attr:`n_entangled`) --</span>
<span class="sd">    Right Schmidt vectors.</span>

<span class="sd">    Each row contains the occupation of all entangled :math:`\gamma_R^\dagger`</span>
<span class="sd">    excitations, described by ``vR[:, nR-n_entangled:nR]``,</span>
<span class="sd">    in one right Schmidt vector, if :attr:`vR` is not :obj:`None`.</span>

<span class="sd">    If both  :attr:`left_sets` and :attr:`right_sets` are computed,</span>
<span class="sd">    they are related by ``left_sets = right_sets[:, ::-1]``.&quot;&quot;&quot;</span>
    <span class="n">schmidt_values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;array (:attr:`n_schmidt`,):</span>
<span class="sd">    Schmidt values :math:`\lambda_\alpha` corresponding to each Schmidt vector.</span>
<span class="sd">    </span>
<span class="sd">    Collated by number of Boguliubov excitations (cf. :attr:`idx_n`);</span>
<span class="sd">    sorted in decreasing order within each excitation-number sector.&quot;&quot;&quot;</span>
    <span class="n">idx_n</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">slice</span><span class="p">]</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Dictionary mapping the number of :math:`\gamma^\dagger` excitations</span>
<span class="sd">    to slice of sets/singular values corresponding to that excitation number.</span>

<span class="sd">    That is, each row in ``left_sets[idx_n[n]]`` contains n ``True`` entries.</span>

<span class="sd">    Slices follow each other in the order 0, 2,..., 1, 3,...</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">idx_parity</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">slice</span><span class="p">]</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Dictionary mapping the parity (0 or 1) of :math:`\gamma^\dagger` excitations</span>
<span class="sd">    to slice of sets/singular values corresponding to that excitation number.</span>

<span class="sd">    That is, each row in ``left_sets[idx_parity[n]]`` contains an even (odd)</span>
<span class="sd">    number of ``True`` entries if n=0 (1).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">n_schmidt</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of Schmidt vectors.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">schmidt_values</span><span class="o">.</span><span class="n">size</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">n_entangled</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of entangled orbitals.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="o">.</span><span class="n">n_entangled</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nL</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Size of the left half of the system.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="o">.</span><span class="n">nL</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nR</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Size of the right half of the system.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="o">.</span><span class="n">nR</span>

<div class="viewcode-block" id="SchmidtVectors.size">
<a class="viewcode-back" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.size">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;T&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Size of the specified half or the whole of the system.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        which:</span>
<span class="sd">            Either &quot;L&quot; for left or &quot;R&quot; for right side</span>
<span class="sd">            or &quot;T&quot; (default) for total size.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            the appropriate system size.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">which</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">vL</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Left Schmidt mode orbitals :attr:`~SchmidtModes.vL`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="o">.</span><span class="n">vL</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">vR</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Right Schmidt mode orbitals :attr:`~SchmidtModes.vR`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="o">.</span><span class="n">vR</span>

<div class="viewcode-block" id="SchmidtVectors.mode_vectors">
<a class="viewcode-back" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.mode_vectors">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mode_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">entangled</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the Schmidt mode orbitals on the specified side.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        which:</span>
<span class="sd">            Either &quot;L&quot; for left or &quot;R&quot; for right side.</span>
<span class="sd">        entangled:</span>
<span class="sd">            Whether to return the entangled (:obj:`True`) or</span>
<span class="sd">            all (:obj:`False`, default) eigenvectors.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            Either :attr:`vL` or :attr:`vR`, depending on ``which``,</span>
<span class="sd">            truncated to entangled modes if ``entangled``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="o">.</span><span class="n">mode_vectors</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="n">entangled</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">pL</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parity of left Boguliubov vacuum :attr:`~SchmidtModes.pL`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="o">.</span><span class="n">pL</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">pR</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parity of right Boguliubov vacuum :attr:`~SchmidtModes.pR`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="o">.</span><span class="n">pR</span>

<div class="viewcode-block" id="SchmidtVectors.parity">
<a class="viewcode-back" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.parity">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">parity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;T&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parity of the Boguliubov vacuum on the specified half of the system.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        which:</span>
<span class="sd">            Either &quot;L&quot; for left or &quot;R&quot; for right side</span>
<span class="sd">            or &quot;T&quot; (default) for the overall parity of the state.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            :attr:`~SchmidtModes.pL`, :attr:`~SchmidtModes.pR`,</span>
<span class="sd">            or the overall parity, depending on ``which``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="o">.</span><span class="n">parity</span><span class="p">(</span><span class="n">which</span><span class="p">)</span></div>


<div class="viewcode-block" id="SchmidtVectors.sets">
<a class="viewcode-back" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.sets">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the sets of Boguliubov excitations on the specified side.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        which:</span>
<span class="sd">            Either &quot;L&quot; for left or &quot;R&quot; for right side.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            Either :attr:`left_sets` or :attr:`right_sets`, depending on ``which``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">which_</span> <span class="o">=</span> <span class="n">which</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">which_</span> <span class="o">==</span> <span class="s2">&quot;L&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">left_sets</span>
        <span class="k">elif</span> <span class="n">which_</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">right_sets</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`which` must start with L or R, got &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">which</span><span class="p">))</span></div>


<div class="viewcode-block" id="SchmidtVectors.from_schmidt_modes">
<a class="viewcode-back" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.from_schmidt_modes">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_schmidt_modes</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="s2">&quot;SchmidtVectors&quot;</span><span class="p">],</span>
        <span class="n">modes</span><span class="p">:</span> <span class="n">SchmidtModes</span><span class="p">,</span>
        <span class="n">trunc_par</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="n">StoppingCondition</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;SchmidtVectors&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Generates the most significant :class:`SchmidtVectors` from an</span>
<span class="sd">        instance of :class:`SchmidtModes`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        modes:</span>
<span class="sd">            The Schmidt modes.</span>
<span class="sd">        trunc_par:</span>
<span class="sd">            Specifies which Schmidt states should be kept.</span>

<span class="sd">            Must be either a :class:`~temfpy.schmidt_utils.StoppingCondition` object</span>
<span class="sd">            or a dictionary with matching keys.</span>

<span class="sd">            The filtering function `is_sector` is applied to the number of</span>
<span class="sd">            :math:`\gamma^\dagger` excitations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trunc_par</span> <span class="o">=</span> <span class="n">to_stopping_condition</span><span class="p">(</span><span class="n">trunc_par</span><span class="p">)</span>

        <span class="c1"># The ratio of excited Schmidt states&#39; weight relative to vacua is the product</span>
        <span class="c1"># of the weights of each included γ† relative to the corresponding γ</span>
        <span class="c1"># Find the sets with the largest products of these</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">sets</span> <span class="o">=</span> <span class="n">lowest_sums</span><span class="p">(</span><span class="n">modes</span><span class="o">.</span><span class="n">e_ratio</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">trunc_par</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">err</span> <span class="o">=</span> <span class="s2">&quot;No Schmidt vectors left after filtering by `trunc_par.sectors`!&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>

        <span class="c1"># collate `sets` by number and parity of excitations</span>
        <span class="n">exc</span> <span class="o">=</span> <span class="n">sets</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">idx</span><span class="p">,</span> <span class="n">idx_n</span><span class="p">,</span> <span class="n">idx_parity</span> <span class="o">=</span> <span class="n">_parity_n_argsort</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
        <span class="n">sets</span> <span class="o">=</span> <span class="n">sets</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="c1"># embed `sets` into the full span of Schmidt modes</span>
        <span class="n">left_sets</span><span class="p">,</span> <span class="n">right_sets</span> <span class="o">=</span> <span class="n">modes</span><span class="o">.</span><span class="n">embed_subsets</span><span class="p">(</span><span class="n">sets</span><span class="p">)</span>
        <span class="c1"># compute Schmidt values</span>
        <span class="n">λ</span> <span class="o">=</span> <span class="n">modes</span><span class="o">.</span><span class="n">schmidt_values</span><span class="p">(</span><span class="n">sets</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> Schmidt vectors generated&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">λ</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Dynamical range: </span><span class="si">%.3e</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">λ</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">/</span> <span class="n">λ</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">modes</span><span class="o">=</span><span class="n">modes</span><span class="p">,</span>
            <span class="n">left_sets</span><span class="o">=</span><span class="n">left_sets</span><span class="p">,</span>
            <span class="n">right_sets</span><span class="o">=</span><span class="n">right_sets</span><span class="p">,</span>
            <span class="n">schmidt_values</span><span class="o">=</span><span class="n">λ</span><span class="p">,</span>
            <span class="n">idx_n</span><span class="o">=</span><span class="n">idx_n</span><span class="p">,</span>
            <span class="n">idx_parity</span><span class="o">=</span><span class="n">idx_parity</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="SchmidtVectors.from_correlation_matrix">
<a class="viewcode-back" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.from_correlation_matrix">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_correlation_matrix</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="s2">&quot;SchmidtVectors&quot;</span><span class="p">],</span>
        <span class="n">C</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">trunc_par</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="n">StoppingCondition</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">basis</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">which</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;LR&quot;</span><span class="p">,</span>
        <span class="n">diag_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_DIAG_TOL</span><span class="p">,</span>
        <span class="n">total_parity</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;SchmidtVectors&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the most significant :class:`SchmidtVectors` of a Nambu</span>
<span class="sd">        mean-field state with correlation matrix C for an entanglement cut</span>
<span class="sd">        between sites ``x-1`` and ``x`` (zero-indexed).</span>

<span class="sd">        Calls :meth:`SchmidtModes.from_correlation_matrix` (see there for</span>
<span class="sd">        details of the parameters) and :meth:`from_schmidt_modes`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">which</span> <span class="o">=</span> <span class="n">which</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="n">trunc_par</span> <span class="o">=</span> <span class="n">to_stopping_condition</span><span class="p">(</span><span class="n">trunc_par</span><span class="p">)</span>

        <span class="n">modes</span> <span class="o">=</span> <span class="n">SchmidtModes</span><span class="o">.</span><span class="n">from_correlation_matrix</span><span class="p">(</span>
            <span class="n">C</span><span class="p">,</span>
            <span class="n">x</span><span class="p">,</span>
            <span class="n">trunc_par</span><span class="p">,</span>
            <span class="n">basis</span><span class="o">=</span><span class="n">basis</span><span class="p">,</span>
            <span class="n">which</span><span class="o">=</span><span class="n">which</span><span class="p">,</span>
            <span class="n">diag_tol</span><span class="o">=</span><span class="n">diag_tol</span><span class="p">,</span>
            <span class="n">total_parity</span><span class="o">=</span><span class="n">total_parity</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">vectors</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_schmidt_modes</span><span class="p">(</span><span class="n">modes</span><span class="p">,</span> <span class="n">trunc_par</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vectors</span></div>
</div>



<span class="c1">#### CONSTRUCTING MPS TENSORS ####</span>
<span class="c1">#### ------------------------ ####</span>


<span class="c1">#### Overlap of Boguliubov states ####</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_pfaffian_matrix</span><span class="p">(</span>
    <span class="n">V1</span><span class="p">,</span> <span class="n">V2</span><span class="p">,</span> <span class="n">sets1</span><span class="p">,</span> <span class="n">sets2</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">min_SV</span><span class="o">=</span><span class="mf">1e-6</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="c1"># NB this docstring doesn&#39;t go into sphinx, don&#39;t bother beautifying it</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes the Pfaffian entries for all bogulon excitations that</span>
<span class="sd">    appear in at least one Schmidt state.</span>

<span class="sd">    First, the Schmidt modes of the &quot;ket&quot; basis, V2, are expressed</span>
<span class="sd">    in terms of the &quot;bra&quot; basis, V1, as Vr = inv(V1) @ V2.</span>
<span class="sd">    We also check that the resulting U is parity even and invertible.</span>

<span class="sd">    Then, if</span>
<span class="sd">        Vr = (U V*)</span>
<span class="sd">             (V U*)</span>
<span class="sd">    the vacuum of the &quot;ket&quot; basis is</span>
<span class="sd">        |vac_B&gt; = exp(1/2 M_ij a†_i a†_j) |vac_A&gt;</span>
<span class="sd">    where the a† are creation operators in the &quot;bra&quot; basis and</span>
<span class="sd">        M = V* @ inv(U*).</span>

<span class="sd">    Now we need overlaps of the type</span>
<span class="sd">        &lt;vac_A| a_ik ... a_i1 b†_j1 ... b†_jl |vac_B&gt;,</span>
<span class="sd">    which can be computed as the Pfaffian of a diagonal submatrix of</span>
<span class="sd">    the matrix N generated by this function.</span>

<span class="sd">    N has a row and a column for each active a and b† (i.e., those that</span>
<span class="sd">    are excited in at least one Schmidt vector). They are listed in</span>
<span class="sd">    reverse order of b†, then regular order of a.</span>
<span class="sd">    The entries of each block are:</span>
<span class="sd">        (b†,b†): N_BB = V^T (MV - U) = -V^T inv(U†) = inv(U*) V</span>
<span class="sd">        (a,a): N_AA = M</span>
<span class="sd">        (a,b†): N_AB = MV - U = -inv(U†),</span>
<span class="sd">        (b†,a): N_BA = -N_AB^T = inv(U*)</span>
<span class="sd">    Each of these formulas are restricted to the active modes.</span>

<span class="sd">    Since |vac_B&gt; as defined above is not normalised, we also compute</span>
<span class="sd">    the overlap of the normalised vacua from the Onishi formula.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        V1, V2:</span>
<span class="sd">            Schmidt-Nambu orbital vectors in the bra and ket bases</span>
<span class="sd">        sets1, sets2:</span>
<span class="sd">            excitations of Schmidt-Nambu orbitals in the bra and ket Schmidt vectors</span>
<span class="sd">        mode:</span>
<span class="sd">            if &quot;left&quot; (&quot;right&quot;), the active a,b† modes are taken from the</span>
<span class="sd">            end (start) of the relevant segment of V1,V2</span>
<span class="sd">        tolerance:</span>
<span class="sd">            numerical tolerance applied for various comparisons</span>
<span class="sd">        min_SV:</span>
<span class="sd">            smallest acceptable singular value of U before it is considered singular</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        norm:</span>
<span class="sd">            overlap of the normalised &lt;vac_A|vac_B&gt;</span>
<span class="sd">        N:</span>
<span class="sd">            the Pfaffian matrix described above.</span>
<span class="sd">            new_sets* index the rows/columns of this matrix.</span>
<span class="sd">        new_sets1:</span>
<span class="sd">            sets1 with any inactive modes removed and prepended</span>
<span class="sd">            with False for the ket modes.</span>
<span class="sd">        new_sets2:</span>
<span class="sd">            sets2 with any inactive modes removed, reversed,</span>
<span class="sd">            and appended with False for the bra modes.</span>
<span class="sd">        split:</span>
<span class="sd">            index of first a mode</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">        The two vacua are expected to have an overlap. In particular,</span>
<span class="sd">        their parities must match.</span>
<span class="sd">        There is no attempt to ensure that a distinguished &quot;physical leg&quot;</span>
<span class="sd">        be retained. This has to be handled by the caller.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># sanity checks</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">V1</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">assert</span> <span class="n">n</span> <span class="o">==</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">assert</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">assert</span> <span class="n">V2</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
    <span class="c1"># mapping between bra and ket basis</span>
    <span class="n">Vr</span> <span class="o">=</span> <span class="n">HT</span><span class="p">(</span><span class="n">V1</span><span class="p">)</span> <span class="o">@</span> <span class="n">V2</span>  <span class="c1"># use that V1 is unitary</span>

    <span class="c1"># check that it has expected Nambu structure</span>
    <span class="c1"># NB operators and daggers are now fully blocked along both axes</span>
    <span class="n">nambu_err</span> <span class="o">=</span> <span class="s2">&quot;Nambu symmetry violated&quot;</span>
    <span class="n">assert_allclose</span><span class="p">(</span>
        <span class="n">Vr</span><span class="p">[:</span><span class="n">L</span><span class="p">,</span> <span class="p">:</span><span class="n">L</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">Vr</span><span class="p">[</span><span class="n">L</span><span class="p">:,</span> <span class="n">L</span><span class="p">:],</span> <span class="n">rtol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">err_msg</span><span class="o">=</span><span class="n">nambu_err</span>
    <span class="p">)</span>
    <span class="n">assert_allclose</span><span class="p">(</span>
        <span class="n">Vr</span><span class="p">[:</span><span class="n">L</span><span class="p">,</span> <span class="n">L</span><span class="p">:]</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">Vr</span><span class="p">[</span><span class="n">L</span><span class="p">:,</span> <span class="p">:</span><span class="n">L</span><span class="p">],</span> <span class="n">rtol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">err_msg</span><span class="o">=</span><span class="n">nambu_err</span>
    <span class="p">)</span>

    <span class="c1"># check that vacua have finite overlap (i.e. U has all positive SVs)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="n">Vr</span><span class="p">[:</span><span class="n">L</span><span class="p">,</span> <span class="p">:</span><span class="n">L</span><span class="p">],</span> <span class="n">compute_uv</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Boguliubov vacuum overlap: </span><span class="si">{</span><span class="n">s</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span><span class="si">:</span><span class="s2">.3e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Range of singular values: (</span><span class="si">{</span><span class="n">s</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="si">:</span><span class="s2">.3e</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="si">:</span><span class="s2">.3e</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    <span class="n">assert_array_less</span><span class="p">(</span>
        <span class="n">min_SV</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">err_msg</span><span class="o">=</span><span class="s2">&quot;Boguliubov vacua do not overlap (U nearly singular)&quot;</span>
    <span class="p">)</span>
    <span class="c1"># compute normalising factor from Onishi formula</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span> <span class="o">**</span> <span class="mf">0.5</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">prune</span><span class="p">(</span><span class="n">sets</span><span class="p">,</span> <span class="n">reverse</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Eliminates all-false columns of `sets` and returns the</span>
<span class="sd">        list of indices to prune other matrices. If `reverse`, also</span>
<span class="sd">        flips the order of columns and indices.&quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">sets</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">(</span><span class="n">idx</span><span class="p">,)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">sets</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">],</span> <span class="n">idx</span>

    <span class="n">active1</span> <span class="o">=</span> <span class="n">sets1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># that is, active modes before pruning</span>
    <span class="n">active2</span> <span class="o">=</span> <span class="n">sets2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">sets1</span><span class="p">,</span> <span class="n">idx1</span> <span class="o">=</span> <span class="n">prune</span><span class="p">(</span><span class="n">sets1</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>  <span class="c1"># a modes</span>
    <span class="n">sets2</span><span class="p">,</span> <span class="n">idx2</span> <span class="o">=</span> <span class="n">prune</span><span class="p">(</span><span class="n">sets2</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>  <span class="c1"># b† modes</span>

    <span class="c1"># embed idx into the full arrays</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span>  <span class="c1"># active modes at end</span>
        <span class="n">idx1</span> <span class="o">+=</span> <span class="n">L</span> <span class="o">-</span> <span class="n">active1</span>
        <span class="n">idx2</span> <span class="o">+=</span> <span class="n">L</span> <span class="o">-</span> <span class="n">active2</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span>  <span class="c1"># right -&gt; active modes at front -&gt; nothing to do</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`mode` must be &quot;left&quot; or &quot;right&quot;&#39;</span><span class="p">)</span>

    <span class="c1"># will need the inverse of U* or U† several times</span>
    <span class="n">Uxinv</span> <span class="o">=</span> <span class="n">inv</span><span class="p">(</span><span class="n">Vr</span><span class="p">[</span><span class="n">L</span><span class="p">:,</span> <span class="n">L</span><span class="p">:])</span>

    <span class="c1"># AA block: M = V* inv(U*)</span>
    <span class="n">AA</span> <span class="o">=</span> <span class="n">Vr</span><span class="p">[</span><span class="n">idx1</span><span class="p">,</span> <span class="n">L</span><span class="p">:]</span> <span class="o">@</span> <span class="n">Uxinv</span><span class="p">[:,</span> <span class="n">idx1</span><span class="p">]</span>
    <span class="c1"># BA block: inv(U*)</span>
    <span class="n">BA</span> <span class="o">=</span> <span class="n">Uxinv</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">idx2</span><span class="p">,</span> <span class="n">idx1</span><span class="p">)]</span>
    <span class="c1"># BB block: inv(U*) V</span>
    <span class="n">BB</span> <span class="o">=</span> <span class="n">Uxinv</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span> <span class="o">@</span> <span class="n">Vr</span><span class="p">[</span><span class="n">L</span><span class="p">:,</span> <span class="n">idx2</span><span class="p">]</span>

    <span class="c1"># check antisymmetry</span>
    <span class="n">assert_allclose</span><span class="p">(</span><span class="n">AA</span><span class="p">,</span> <span class="o">-</span><span class="n">AA</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">err_msg</span><span class="o">=</span><span class="n">nambu_err</span><span class="p">)</span>
    <span class="n">AA</span> <span class="o">=</span> <span class="p">(</span><span class="n">AA</span> <span class="o">-</span> <span class="n">AA</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">assert_allclose</span><span class="p">(</span><span class="n">BB</span><span class="p">,</span> <span class="o">-</span><span class="n">BB</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">err_msg</span><span class="o">=</span><span class="n">nambu_err</span><span class="p">)</span>
    <span class="n">BB</span> <span class="o">=</span> <span class="p">(</span><span class="n">BB</span> <span class="o">-</span> <span class="n">BB</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="c1"># assemble Pfaffian matrix</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([[</span><span class="n">BB</span><span class="p">,</span> <span class="n">BA</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="n">BA</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">AA</span><span class="p">]])</span>

    <span class="c1"># expand sets1, sets2</span>
    <span class="n">new_sets1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
        <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">sets1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sets2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span> <span class="n">sets1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">)</span>
    <span class="n">new_sets2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
        <span class="p">(</span><span class="n">sets2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">sets2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sets1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">norm</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">new_sets1</span><span class="p">,</span> <span class="n">new_sets2</span><span class="p">,</span> <span class="n">sets2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_many_pfaffian</span><span class="p">(</span><span class="n">matrices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes a bunch of Pfaffians by iterating through them with</span>
<span class="sd">    :func:`pfapack.ctypes.pfaffian`.</span>

<span class="sd">    If the input has shape ``(...,N,N)``, returns an array of shape ``(...)``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">err</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Expected square matrices in the last two axes, got </span><span class="si">{</span><span class="n">matrices</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">matrices</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">matrices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">matrices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]),</span> <span class="n">err</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">matrices</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">matrices</span> <span class="o">=</span> <span class="n">matrices</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="o">*</span><span class="n">matrices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span>
    <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">(</span><span class="n">category</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">ComplexWarning</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
        <span class="n">pf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">cpf</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">A</span> <span class="ow">in</span> <span class="n">matrices</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">pf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_tensor_block</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">new_sets1</span><span class="p">,</span> <span class="n">new_sets2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes a fixed-bogulon-number block of the MPS tensor.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        N:</span>
<span class="sd">            the Pfaffian matrix generated by `_pfaffian_matrix`</span>
<span class="sd">        new_sets1, new_sets2:</span>
<span class="sd">            rows of `new_sets` returned by `_pfaffian_matrix` with</span>
<span class="sd">            fixed excitation numbers.</span>

<span class="sd">            `new_sets1` must include the physical leg too, with</span>
<span class="sd">            any necessary adjustments for parity</span>

<span class="sd">    Returns:</span>
<span class="sd">        the MPS tensor block as a matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># check that every new_set has the same number of particles</span>
    <span class="n">n1</span> <span class="o">=</span> <span class="n">new_sets1</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">n1</span> <span class="o">==</span> <span class="n">n1</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="s2">&quot;Bra sets of different excitation numbers supplied&quot;</span>
    <span class="n">n1</span> <span class="o">=</span> <span class="n">n1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">n2</span> <span class="o">=</span> <span class="n">new_sets2</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">n2</span> <span class="o">==</span> <span class="n">n2</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="s2">&quot;Ket sets of different excitation numbers supplied&quot;</span>
    <span class="n">n2</span> <span class="o">=</span> <span class="n">n2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># check parity conservation</span>
    <span class="k">assert</span> <span class="n">n1</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="n">n2</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Bra and ket excitations do not preserve parity&quot;</span>

    <span class="c1"># convert new_sets to lists of positions</span>
    <span class="n">ns1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_sets1</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">new_sets1</span> <span class="o">=</span> <span class="n">new_sets1</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
    <span class="n">new_sets1</span> <span class="o">=</span> <span class="n">new_sets1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ns1</span><span class="p">,</span> <span class="n">n1</span><span class="p">)</span>

    <span class="n">ns2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_sets2</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">new_sets2</span> <span class="o">=</span> <span class="n">new_sets2</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
    <span class="n">new_sets2</span> <span class="o">=</span> <span class="n">new_sets2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ns2</span><span class="p">,</span> <span class="n">n2</span><span class="p">)</span>

    <span class="c1"># broadcast and concatenate indices</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">new_sets2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">ns1</span><span class="p">,</span> <span class="n">ns2</span><span class="p">,</span> <span class="n">n2</span><span class="p">)),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">new_sets1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">ns1</span><span class="p">,</span> <span class="n">ns2</span><span class="p">,</span> <span class="n">n1</span><span class="p">)),</span>
        <span class="p">),</span>
        <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># extract matching rows and columns</span>
    <span class="n">O</span> <span class="o">=</span> <span class="n">N</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
    <span class="n">O</span> <span class="o">=</span> <span class="n">_many_pfaffian</span><span class="p">(</span><span class="n">O</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">O</span>


<span class="c1">#### Tenpy helper functions ####</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_make_legcharge</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">parity</span><span class="p">,</span> <span class="n">qconj</span><span class="o">=+</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Builds a LegCharge object from the given parity slices,</span>
<span class="sd">    offset by a reference parity.&quot;&quot;&quot;</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="p">{(</span><span class="n">i</span> <span class="o">+</span> <span class="n">parity</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span> <span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">npc</span><span class="o">.</span><span class="n">LegCharge</span><span class="o">.</span><span class="n">from_qdict</span><span class="p">(</span><span class="n">chinfo</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">qconj</span><span class="o">=</span><span class="n">qconj</span><span class="p">)</span>


<div class="viewcode-block" id="MPSTensorData">
<a class="viewcode-back" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData">[docs]</a>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MPSTensorData</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Data for computing one MPS tensor of a Pfaffian state.</span>

<span class="sd">    - If :attr:`mode` is ``&quot;left&quot;``, contains an implicit description of the</span>
<span class="sd">      left canonical tensor</span>

<span class="sd">      .. math::</span>

<span class="sd">        A^{n_i}_{\alpha\beta} =</span>
<span class="sd">        (\langle n_i | \otimes_g \langle L^{(i-1)}_{\alpha}|)</span>
<span class="sd">        |L^{(i)}_{\beta} \rangle.</span>

<span class="sd">    - If :attr:`mode` is ``&quot;right&quot;``, contains an implicit description of the</span>
<span class="sd">      right canonical tensor</span>

<span class="sd">      .. math::</span>

<span class="sd">        B^{n_i}_{\beta\alpha} =</span>
<span class="sd">        (\langle R^{(i)}_\alpha| \otimes_g \langle n_i|)</span>
<span class="sd">        |R^{(i-1)}_\beta \rangle.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Whether the overlap is between ``&quot;left&quot;`` or ``&quot;right&quot;`` Schmidt vectors.&quot;&quot;&quot;</span>
    <span class="n">norm</span><span class="p">:</span> <span class="nb">float</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Overlap of the normalised Boguliubov vacua for the two entanglement cuts.&quot;&quot;&quot;</span>
    <span class="n">pfaffian_matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Matrix of Pfaffian entries for all bogulon excitations that appear in</span>
<span class="sd">    at least one Schmidt state.</span>
<span class="sd">    </span>
<span class="sd">    It is a block matrix, with the first rows/columns corresponding to excitations</span>
<span class="sd">    on the ket side, followed by excitations on the bra side.&quot;&quot;&quot;</span>
    <span class="n">labels</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Labels of the bra and ket leg(pipe)s.&quot;&quot;&quot;</span>
    <span class="n">qtotal</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Total fermion parity of the tensor to ensure matching parities in</span>
<span class="sd">    Schmidt vectors.</span>
<span class="sd">    </span>
<span class="sd">    - 0 if ``mode == &quot;left&quot;``.</span>
<span class="sd">    - 0 if ``mode == &quot;right&quot;`` and virtual legs are labelled</span>
<span class="sd">      with fermion parity to the right.</span>
<span class="sd">    - Otherwise, difference of total fermion parity between</span>
<span class="sd">      the ket and bra Schmidt vectors.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">leg_bra</span><span class="p">:</span> <span class="n">npc</span><span class="o">.</span><span class="n">LegCharge</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Tensor leg corresponding to the bra Schmidt vectors.</span>

<span class="sd">    If the tensor contains a physical leg, it is united to the bra leg as </span>
<span class="sd">    an `unsorted` :class:`tenpy.linalg.charges.LegPipe`.&quot;&quot;&quot;</span>
    <span class="n">new_sets_bra</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Bra Schmidt vectors in terms of the excitations in :attr:`pfaffian_matrix`.</span>
<span class="sd">    </span>
<span class="sd">    Given the block structure of :attr:`pfaffian_matrix`, each row starts with</span>
<span class="sd">    a number of ``False`` entries corresponding to the ket excitations.</span>
<span class="sd">    </span>
<span class="sd">    If the tensor contains a physical leg, it is double the length of</span>
<span class="sd">    :attr:`~SchmidtVectors.sets` and contains all Schmidt vectors with the on-site</span>
<span class="sd">    degree of freedom once empty, one filled.</span>
<span class="sd">     </span>
<span class="sd">    If needed for matching the bra and ket parities, the Boguliubov orbital</span>
<span class="sd">    with λ closest to 1/2 is particle-hole flipped. </span>

<span class="sd">    After all this, the sets are resorted by parity and number of Boguliubov</span>
<span class="sd">    excitations.&quot;&quot;&quot;</span>
    <span class="n">idx_n_bra</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Analogue of :attr:`~SchmidtVectors.idx_n` for :attr:`new_sets_bra`.&quot;&quot;&quot;</span>
    <span class="n">leg_idx_bra</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mapping between :attr:`leg_bra` and :attr:`new_sets_bra`.</span>
<span class="sd">    </span>
<span class="sd">    Namely, ``leg_idx_bra[i]`` gives the index in :attr:`leg_bra`</span>
<span class="sd">    corresponding to ``new_sets_bra[i]``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">leg_ket</span><span class="p">:</span> <span class="n">npc</span><span class="o">.</span><span class="n">LegCharge</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Tensor leg corresponding to the ket Schmidt vectors.&quot;&quot;&quot;</span>
    <span class="n">new_sets_ket</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Ket Schmidt vectors in terms of the excitations in :attr:`pfaffian_matrix`.</span>
<span class="sd">    </span>
<span class="sd">    Given the block structure of :attr:`pfaffian_matrix`, each row ends with</span>
<span class="sd">    a number of ``False`` entries corresponding to the bra excitations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">idx_n_ket</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;:attr:`~SchmidtVectors.idx_n` of the ket Schmidt vector.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="MPSTensorData.from_schmidt_vectors">
<a class="viewcode-back" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData.from_schmidt_vectors">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_schmidt_vectors</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="s2">&quot;MPSTensorData&quot;</span><span class="p">],</span>
        <span class="n">Schmidt_bra</span><span class="p">:</span> <span class="n">SchmidtVectors</span><span class="p">,</span>
        <span class="n">Schmidt_ket</span><span class="p">:</span> <span class="n">SchmidtVectors</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">nambu_tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span>
        <span class="n">min_SV</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;MPSTensorData&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Builds an :class:`MPSTensorData` object from the Schmidt vectors of</span>
<span class="sd">        the two surrounding entanglement cuts.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Schmidt_bra:</span>
<span class="sd">            Schmidt vectors on the &quot;bra&quot; side.</span>

<span class="sd">            That is, for the entanglement cut to the left if ``mode==&quot;left&quot;``</span>
<span class="sd">            or to the right if ``mode=&quot;right&quot;``.</span>

<span class="sd">            Must contain a description of left (right) Schmidt vectors if</span>
<span class="sd">            ``mode==&quot;left&quot;`` (``&quot;right&quot;``).</span>
<span class="sd">        Schmidt_ket:</span>
<span class="sd">            Schmidt vectors on the &quot;ket&quot; side.</span>

<span class="sd">            That is, for the entanglement cut to the right if ``mode==&quot;left&quot;``</span>
<span class="sd">            or to the left if ``mode=&quot;right&quot;``.</span>

<span class="sd">            Must contain a description of left (right) Schmidt vectors if</span>
<span class="sd">            ``mode==&quot;left&quot;`` (``&quot;right&quot;``).</span>
<span class="sd">        mode:</span>
<span class="sd">            Specifies which Schmidt vectors are used to build the MPS tensor</span>
<span class="sd">            and the canonical form the tensor is computed in.</span>
<span class="sd">        nambu_tolerance:</span>
<span class="sd">            numerical tolerance for checking Nambu symmetry</span>
<span class="sd">        min_SV:</span>
<span class="sd">            smallest acceptable singular value of U before it is considered singular</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;mode must be either &#39;left&#39; or &#39;right&#39;, got &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>

        <span class="c1"># shorthands</span>
        <span class="n">v_bra</span> <span class="o">=</span> <span class="n">Schmidt_bra</span><span class="o">.</span><span class="n">mode_vectors</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">v_bra</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;`Schmidt_bra` contains no </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2"> Schmidt vectors&quot;</span>
        <span class="n">sets_bra</span> <span class="o">=</span> <span class="n">Schmidt_bra</span><span class="o">.</span><span class="n">sets</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>

        <span class="n">v_ket</span> <span class="o">=</span> <span class="n">Schmidt_ket</span><span class="o">.</span><span class="n">mode_vectors</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">v_ket</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;`Schmidt_ket` contains no </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2"> Schmidt vectors&quot;</span>

        <span class="c1"># virtual legs of the MPS tensor</span>
        <span class="n">p_bra</span> <span class="o">=</span> <span class="n">Schmidt_bra</span><span class="o">.</span><span class="n">pL</span>
        <span class="n">p_ket</span> <span class="o">=</span> <span class="n">Schmidt_ket</span><span class="o">.</span><span class="n">pL</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p_bra</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">p_ket</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>  <span class="c1"># only happens if mode == &quot;right&quot;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Parity to the left is unknown.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;Virtual legs will carry parity to the right!&quot;</span>
            <span class="p">)</span>
            <span class="n">p_bra</span> <span class="o">=</span> <span class="n">Schmidt_bra</span><span class="o">.</span><span class="n">pR</span>
            <span class="n">p_ket</span> <span class="o">=</span> <span class="n">Schmidt_ket</span><span class="o">.</span><span class="n">pR</span>
            <span class="n">qtotal</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span>  <span class="c1"># we have left and right -&gt; total parities</span>
            <span class="n">qtotal</span> <span class="o">=</span> <span class="p">(</span><span class="n">Schmidt_bra</span><span class="o">.</span><span class="n">parity</span><span class="p">()</span> <span class="o">+</span> <span class="n">Schmidt_ket</span><span class="o">.</span><span class="n">parity</span><span class="p">())</span> <span class="o">%</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># mode == &#39;left&#39;</span>
            <span class="n">qtotal</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">qconj</span> <span class="o">=</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span> <span class="k">else</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;vL&quot;</span><span class="p">,</span> <span class="s2">&quot;vR&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span> <span class="k">else</span> <span class="p">[</span><span class="s2">&quot;vR&quot;</span><span class="p">,</span> <span class="s2">&quot;vL&quot;</span><span class="p">]</span>
        <span class="n">leg_bra</span> <span class="o">=</span> <span class="n">_make_legcharge</span><span class="p">(</span><span class="n">Schmidt_bra</span><span class="o">.</span><span class="n">idx_parity</span><span class="p">,</span> <span class="n">p_bra</span><span class="p">,</span> <span class="n">qconj</span><span class="o">=</span><span class="n">qconj</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">leg_ket</span> <span class="o">=</span> <span class="n">_make_legcharge</span><span class="p">(</span><span class="n">Schmidt_ket</span><span class="o">.</span><span class="n">idx_parity</span><span class="p">,</span> <span class="n">p_ket</span><span class="p">,</span> <span class="n">qconj</span><span class="o">=</span><span class="n">qconj</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># bra must be 1 longer than ket</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v_bra</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">v_ket</span><span class="p">):</span>
            <span class="n">ns_bra</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sets_bra</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v_bra</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="c1"># add the physical orbital and combine sets_bra and sets_phys</span>
            <span class="c1"># sets_phys shall be more major to sets_bra</span>
            <span class="n">leg_bra</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">LegPipe</span><span class="p">(</span>
                <span class="p">[</span><span class="n">fermion_leg</span><span class="p">,</span> <span class="n">leg_bra</span><span class="p">],</span> <span class="n">qconj</span><span class="o">=</span><span class="n">leg_bra</span><span class="o">.</span><span class="n">qconj</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bunch</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
            <span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;(p.</span><span class="si">{</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span>

            <span class="n">z_col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">z_row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span>
                <span class="c1"># anticommutation signs:</span>
                <span class="c1"># if bra vacuum is parity odd, flip sign of physical leg</span>
                <span class="n">u_p</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">Schmidt_bra</span><span class="o">.</span><span class="n">parity</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span>
                <span class="c1"># the physical leg ought to be the last on the bra side</span>
                <span class="n">v_bra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="p">[</span><span class="n">v_bra</span><span class="p">[:,</span> <span class="p">:</span><span class="n">n</span><span class="p">],</span> <span class="n">z_col</span><span class="p">,</span> <span class="n">v_bra</span><span class="p">[:,</span> <span class="n">n</span><span class="p">:],</span> <span class="n">z_col</span><span class="p">],</span>
                        <span class="p">[</span><span class="n">z_row</span><span class="p">,</span> <span class="n">u_p</span><span class="p">,</span> <span class="n">z_row</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                        <span class="p">[</span><span class="n">z_row</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">z_row</span><span class="p">,</span> <span class="n">u_p</span><span class="p">],</span>
                    <span class="p">]</span>  <span class="c1"># NB row space keeps c_i and c†_i together</span>
                <span class="p">)</span>
                <span class="n">sets_bra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="p">[</span><span class="n">sets_bra</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ns_bra</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">bool</span><span class="p">)],</span>
                        <span class="p">[</span><span class="n">sets_bra</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">ns_bra</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">bool</span><span class="p">)],</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># mode == &quot;right&quot;:</span>
                <span class="c1"># the physical leg ought to be the first on the bra side</span>
                <span class="n">v_bra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">z_row</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">z_row</span><span class="p">],</span>
                        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">z_row</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">z_row</span><span class="p">],</span>
                        <span class="p">[</span><span class="n">z_col</span><span class="p">,</span> <span class="n">v_bra</span><span class="p">[:,</span> <span class="p">:</span><span class="n">n</span><span class="p">],</span> <span class="n">z_col</span><span class="p">,</span> <span class="n">v_bra</span><span class="p">[:,</span> <span class="n">n</span><span class="p">:]],</span>
                    <span class="p">]</span>  <span class="c1"># NB row space keeps c_i and c†_i together</span>
                <span class="p">)</span>
                <span class="n">sets_bra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ns_bra</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">bool</span><span class="p">),</span> <span class="n">sets_bra</span><span class="p">],</span>
                        <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">ns_bra</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">bool</span><span class="p">),</span> <span class="n">sets_bra</span><span class="p">],</span>
                    <span class="p">]</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">v_bra</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">v_ket</span><span class="p">):</span>
            <span class="c1"># copy v_bra and sets_bra if parity fix needed</span>
            <span class="k">if</span> <span class="n">Schmidt_bra</span><span class="o">.</span><span class="n">parity</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="n">Schmidt_ket</span><span class="o">.</span><span class="n">parity</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">v_bra</span> <span class="o">=</span> <span class="n">v_bra</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">setflags</span><span class="p">(</span><span class="n">write</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">sets_bra</span> <span class="o">=</span> <span class="n">sets_bra</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">setflags</span><span class="p">(</span><span class="n">write</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">mode</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span><span class="si">}</span><span class="s2"> sides `Schmidt_bra` and `Schmidt_ket` must match</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;or `Schmidt_bra` must be one bond to the </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2"> of `Schmidt_ket`,</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;got lengths </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">v_bra</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">2</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">v_ket</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">2</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># fix reference parity</span>
        <span class="k">if</span> <span class="n">Schmidt_bra</span><span class="o">.</span><span class="n">parity</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="n">Schmidt_ket</span><span class="o">.</span><span class="n">parity</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># flip the &quot;most entangled&quot; bra mode, i.e. last for left, first for right</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v_bra</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span>
                <span class="n">v_bra</span><span class="p">[:,</span> <span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">v_bra</span><span class="p">[:,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span>
                <span class="n">sets_bra</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">sets_bra</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># mode == &quot;right&quot;:</span>
                <span class="c1"># anticommutation signs:</span>
                <span class="c1"># need to flip sign of all other Boguliubov operators</span>
                <span class="n">v_bra</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">v_bra</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="n">v_bra</span><span class="p">[:,</span> <span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
                <span class="n">sets_bra</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">sets_bra</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="n">norm</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">sets_bra</span><span class="p">,</span> <span class="n">sets_ket</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_pfaffian_matrix</span><span class="p">(</span>
            <span class="n">v_bra</span><span class="p">,</span>
            <span class="n">v_ket</span><span class="p">,</span>
            <span class="n">sets_bra</span><span class="p">,</span>
            <span class="n">Schmidt_ket</span><span class="o">.</span><span class="n">sets</span><span class="p">(</span><span class="n">mode</span><span class="p">),</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">tolerance</span><span class="o">=</span><span class="n">nambu_tolerance</span><span class="p">,</span>
            <span class="n">min_SV</span><span class="o">=</span><span class="n">min_SV</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># sort sets_bra</span>
        <span class="n">leg_idx_bra</span><span class="p">,</span> <span class="n">idx_n_bra</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_parity_n_argsort</span><span class="p">(</span><span class="n">sets_bra</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">sets_bra</span> <span class="o">=</span> <span class="n">sets_bra</span><span class="p">[</span><span class="n">leg_idx_bra</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
            <span class="n">pfaffian_matrix</span><span class="o">=</span><span class="n">N</span><span class="p">,</span>
            <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span>
            <span class="n">qtotal</span><span class="o">=</span><span class="n">qtotal</span><span class="p">,</span>
            <span class="n">leg_bra</span><span class="o">=</span><span class="n">leg_bra</span><span class="p">,</span>
            <span class="n">leg_ket</span><span class="o">=</span><span class="n">leg_ket</span><span class="p">,</span>
            <span class="n">new_sets_bra</span><span class="o">=</span><span class="n">sets_bra</span><span class="p">,</span>
            <span class="n">new_sets_ket</span><span class="o">=</span><span class="n">sets_ket</span><span class="p">,</span>
            <span class="n">idx_n_bra</span><span class="o">=</span><span class="n">idx_n_bra</span><span class="p">,</span>
            <span class="n">idx_n_ket</span><span class="o">=</span><span class="n">Schmidt_ket</span><span class="o">.</span><span class="n">idx_n</span><span class="p">,</span>
            <span class="n">leg_idx_bra</span><span class="o">=</span><span class="n">leg_idx_bra</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="MPSTensorData.to_npc_array">
<a class="viewcode-back" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData.to_npc_array">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_npc_array</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npc</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the MPS tensor as a TeNPy</span>
<span class="sd">        :class:`~tenpy.linalg.np_conserved.Array` object.</span>

<span class="sd">        If :attr:`mode` is &quot;left&quot;, returns a left canonical tensor;</span>
<span class="sd">        if &quot;right&quot;, a right canonical one.&quot;&quot;&quot;</span>

        <span class="c1"># empty tensor</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">leg_bra</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">leg_ket</span><span class="p">],</span>
            <span class="n">labels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span>
            <span class="n">qtotal</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qtotal</span><span class="p">,),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pfaffian_matrix</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># fill the tensor in blocks of fixed bogulon numbers</span>
        <span class="k">for</span> <span class="n">n_bra</span><span class="p">,</span> <span class="n">slice_bra</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_n_bra</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">n_ket</span><span class="p">,</span> <span class="n">slice_ket</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_n_ket</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">n_bra</span> <span class="o">+</span> <span class="n">n_ket</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># compute tensor block</span>
                <span class="n">B</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">leg_idx_bra</span><span class="p">[</span><span class="n">slice_bra</span><span class="p">],</span> <span class="n">slice_ket</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">*</span> <span class="n">_tensor_block</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pfaffian_matrix</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">new_sets_bra</span><span class="p">[</span><span class="n">slice_bra</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">new_sets_ket</span><span class="p">[</span><span class="n">slice_ket</span><span class="p">],</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">B</span><span class="o">.</span><span class="n">split_legs</span><span class="p">()</span></div>
</div>



<span class="c1">#### High-level functions ####</span>
<span class="c1">#### -------------------- ####</span>

<div class="viewcode-block" id="C_to_MPS">
<a class="viewcode-back" href="../../reference/pfaffian.html#temfpy.pfaffian.C_to_MPS">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">C_to_MPS</span><span class="p">(</span>
    <span class="n">C</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">trunc_par</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="n">StoppingCondition</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">basis</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">diag_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_DIAG_TOL</span><span class="p">,</span>
    <span class="n">ortho_center</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">networks</span><span class="o">.</span><span class="n">MPS</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    MPS representation of a Nambu mean-field ground state from its correlation matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    C:</span>
<span class="sd">        Nambu correlation matrix in the basis indicated by ``basis``.</span>
<span class="sd">    trunc_par:</span>
<span class="sd">        Specifies which Schmidt states should be kept.</span>

<span class="sd">        Must be either a :class:`~temfpy.schmidt_utils.StoppingCondition` object</span>
<span class="sd">        or a dictionary with matching keys.</span>

<span class="sd">        Only specify the field ``sectors`` if you know what you are doing!!</span>
<span class="sd">    basis:</span>
<span class="sd">        &quot;M&quot; or &quot;C&quot;, indicates whether the correlation matrix is given</span>
<span class="sd">        in the Majorana or the complex-fermion basis.</span>
<span class="sd">    ortho_center:</span>
<span class="sd">        Orthogonality centre of the mixed canonical MPS.</span>
<span class="sd">        Midpoint of the chain by default.</span>
<span class="sd">    diag_tol:</span>
<span class="sd">        Largest allowed offdiagonal matrix element in diagonalised / SVD</span>
<span class="sd">        correlation submatrices before an error is raised.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        The wave function as a TeNPy :class:`~tenpy.networks.mps.MPS` object.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    - If :attr:`trunc_par.svd_min` is not provided, the truncation threshold</span>
<span class="sd">      defaults to 1e-6.</span>
<span class="sd">    - If :attr:`trunc_par.degeneracy_tol` is not provided, the degeneracy tolerance</span>
<span class="sd">      defaults to 1e-12.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">trunc_par</span> <span class="o">=</span> <span class="n">to_stopping_condition</span><span class="p">(</span><span class="n">trunc_par</span><span class="p">)</span>

    <span class="n">L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="c1"># lists for accumulating the tensors and singular values</span>
    <span class="n">tensors</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">L</span>
    <span class="n">λs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Main bipartition, in the middle if not otherwise specified</span>
    <span class="n">ortho_center</span> <span class="o">=</span> <span class="n">ortho_center</span> <span class="ow">or</span> <span class="n">L</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Central bond </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ortho_center</span><span class="p">)</span>
    <span class="n">Schmidt_center</span> <span class="o">=</span> <span class="n">SchmidtVectors</span><span class="o">.</span><span class="n">from_correlation_matrix</span><span class="p">(</span>
        <span class="n">C</span><span class="p">,</span> <span class="n">ortho_center</span><span class="p">,</span> <span class="n">trunc_par</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="n">basis</span><span class="p">,</span> <span class="n">diag_tol</span><span class="o">=</span><span class="n">diag_tol</span>
    <span class="p">)</span>
    <span class="n">λs</span><span class="p">[</span><span class="n">ortho_center</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalize_SV</span><span class="p">(</span><span class="n">Schmidt_center</span><span class="o">.</span><span class="n">schmidt_values</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
    <span class="n">parity</span> <span class="o">=</span> <span class="n">Schmidt_center</span><span class="o">.</span><span class="n">parity</span><span class="p">()</span>

    <span class="c1"># Right half of the chain</span>
    <span class="n">Schmidt</span> <span class="o">=</span> <span class="n">Schmidt_center</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ortho_center</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Site </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># details of bond to the right</span>
        <span class="n">Schmidt_new</span> <span class="o">=</span> <span class="n">SchmidtVectors</span><span class="o">.</span><span class="n">from_correlation_matrix</span><span class="p">(</span>
            <span class="n">C</span><span class="p">,</span>
            <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">trunc_par</span><span class="p">,</span>
            <span class="n">which</span><span class="o">=</span><span class="s2">&quot;R&quot;</span><span class="p">,</span>
            <span class="n">basis</span><span class="o">=</span><span class="n">basis</span><span class="p">,</span>
            <span class="n">diag_tol</span><span class="o">=</span><span class="n">diag_tol</span><span class="p">,</span>
            <span class="n">total_parity</span><span class="o">=</span><span class="n">parity</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">λs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalize_SV</span><span class="p">(</span><span class="n">Schmidt_new</span><span class="o">.</span><span class="n">schmidt_values</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>

        <span class="c1"># compute the tensor</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">MPSTensorData</span><span class="o">.</span><span class="n">from_schmidt_vectors</span><span class="p">(</span><span class="n">Schmidt_new</span><span class="p">,</span> <span class="n">Schmidt</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">)</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">to_npc_array</span><span class="p">()</span>
        <span class="n">tensors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Tensor norm on site </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">npc</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">λs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="mf">0.5</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">logger</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">):</span>
            <span class="c1"># check accuracy of canonical form</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="p">[[</span><span class="s2">&quot;vR&quot;</span><span class="p">,</span> <span class="s2">&quot;p&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;vR*&quot;</span><span class="p">,</span> <span class="s2">&quot;p*&quot;</span><span class="p">]])</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">to_ndarray</span><span class="p">()</span>
            <span class="n">deviation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">e</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)))</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;RMS RC deviation: </span><span class="si">{</span><span class="n">deviation</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">Schmidt</span> <span class="o">=</span> <span class="n">Schmidt_new</span>

    <span class="c1"># Left half of the chain</span>
    <span class="n">Schmidt</span> <span class="o">=</span> <span class="n">Schmidt_center</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ortho_center</span><span class="p">)):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Site </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># details of bond to the left</span>
        <span class="n">Schmidt_new</span> <span class="o">=</span> <span class="n">SchmidtVectors</span><span class="o">.</span><span class="n">from_correlation_matrix</span><span class="p">(</span>
            <span class="n">C</span><span class="p">,</span>
            <span class="n">i</span><span class="p">,</span>
            <span class="n">trunc_par</span><span class="p">,</span>
            <span class="n">which</span><span class="o">=</span><span class="s2">&quot;L&quot;</span><span class="p">,</span>
            <span class="n">basis</span><span class="o">=</span><span class="n">basis</span><span class="p">,</span>
            <span class="n">diag_tol</span><span class="o">=</span><span class="n">diag_tol</span><span class="p">,</span>
            <span class="n">total_parity</span><span class="o">=</span><span class="n">parity</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">λs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalize_SV</span><span class="p">(</span><span class="n">Schmidt_new</span><span class="o">.</span><span class="n">schmidt_values</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>

        <span class="c1"># compute the tensor</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">MPSTensorData</span><span class="o">.</span><span class="n">from_schmidt_vectors</span><span class="p">(</span><span class="n">Schmidt_new</span><span class="p">,</span> <span class="n">Schmidt</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">to_npc_array</span><span class="p">()</span>
        <span class="n">tensors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Tensor norm on site </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">npc</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">λs</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="mf">0.5</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">logger</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">):</span>
            <span class="c1"># check accuracy of left canonical form</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="p">[[</span><span class="s2">&quot;vL&quot;</span><span class="p">,</span> <span class="s2">&quot;p&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;vL*&quot;</span><span class="p">,</span> <span class="s2">&quot;p*&quot;</span><span class="p">]])</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">to_ndarray</span><span class="p">()</span>
            <span class="n">deviation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">e</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)))</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;RMS LC deviation: </span><span class="si">{</span><span class="n">deviation</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">Schmidt</span> <span class="o">=</span> <span class="n">Schmidt_new</span>

    <span class="n">form</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">ortho_center</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;B&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">L</span> <span class="o">-</span> <span class="n">ortho_center</span><span class="p">)</span>
    <span class="n">mps</span> <span class="o">=</span> <span class="n">networks</span><span class="o">.</span><span class="n">mps</span><span class="o">.</span><span class="n">MPS</span><span class="p">([</span><span class="n">fermion_site</span><span class="p">]</span> <span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="n">tensors</span><span class="p">,</span> <span class="n">λs</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="n">form</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mps</span></div>



<div class="viewcode-block" id="C_to_iMPS">
<a class="viewcode-back" href="../../reference/pfaffian.html#temfpy.pfaffian.C_to_iMPS">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">C_to_iMPS</span><span class="p">(</span>
    <span class="n">C_short</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">C_long</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">trunc_par</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="n">StoppingCondition</span><span class="p">,</span>
    <span class="n">sites_per_cell</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">cut</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">basis</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">diag_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_DIAG_TOL</span><span class="p">,</span>
    <span class="n">unitary_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">iMPS</span><span class="o">.</span><span class="n">_UNITARY_TOL</span><span class="p">,</span>
    <span class="n">schmidt_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">iMPS</span><span class="o">.</span><span class="n">_SCHMIDT_TOL</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">networks</span><span class="o">.</span><span class="n">MPS</span><span class="p">,</span> <span class="n">iMPS</span><span class="o">.</span><span class="n">iMPSError</span><span class="p">]:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;iMPS representation of a Nambu mean-field state from correlation matrices.</span>

<span class="sd">    The two correlation matrices are expected to represent the ground states</span>
<span class="sd">    of a gapped, translation invariant Hamiltonian on two system sizes that</span>
<span class="sd">    differ by one repeating unit cell.</span>

<span class="sd">    The method is analogous to :func:`.iMPS.MPS_to_iMPS`, with two differences:</span>

<span class="sd">    - No explicit MPS tensors are computed for the environment of the iMPS unit</span>
<span class="sd">      cell. Instead, the Schmidt vector overlaps needed for gauge fixing are</span>
<span class="sd">      computed using the Pfaffian state overlap formulas implemented in</span>
<span class="sd">      :class:`MPSTensorData`.</span>
<span class="sd">    - The rightmost tensor is computed directly using the right Schmidt vectors</span>
<span class="sd">      of the shorter chain. This means that no separate :class:`~.iMPS.iMPSError`\ s</span>
<span class="sd">      are returned for the right side.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    C_short:</span>
<span class="sd">        Nambu correlation matrix in the basis indicated by ``basis``</span>
<span class="sd">        for the shorter chain.</span>
<span class="sd">    C_long:</span>
<span class="sd">        Nambu correlation matrix in the basis indicated by ``basis``</span>
<span class="sd">        for the longer chain.</span>
<span class="sd">    trunc_par:</span>
<span class="sd">        Specifies which Schmidt states should be kept.</span>

<span class="sd">        Must be either a :class:`~temfpy.schmidt_utils.StoppingCondition` object</span>
<span class="sd">        or a dictionary with matching keys.</span>

<span class="sd">        Only specify the field ``sectors`` if you know what you are doing!!</span>
<span class="sd">    sites_per_cell:</span>
<span class="sd">        Size of the iMPS unit cell.</span>
<span class="sd">    cut:</span>
<span class="sd">        First site of the repeating unit cell in ``C_long``.</span>
<span class="sd">    basis:</span>
<span class="sd">        &quot;M&quot; or &quot;C&quot;, indicates whether the correlation matrix is given</span>
<span class="sd">        in the Majorana or the complex-fermion basis.</span>
<span class="sd">    diag_tol:</span>
<span class="sd">        Largest allowed offdiagonal matrix element in diagonalised / SVD</span>
<span class="sd">        correlation submatrices before an error is raised.</span>
<span class="sd">    unitary_tol:</span>
<span class="sd">        Maximum deviation of the gauge rotation matrices from unitarity</span>
<span class="sd">        before a warning is raised.</span>
<span class="sd">    schmidt_tol:</span>
<span class="sd">        Maximum mixing of unequal Schmidt values by the gauge rotation matrices</span>
<span class="sd">        before a warning is raised.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    iMPS: :class:`~tenpy.networks.mps.MPS`</span>
<span class="sd">        iMPS with unit cell size ``sites_per_cell``, constructed from the</span>
<span class="sd">        additional unit cell of ``mps_long``.</span>
<span class="sd">    validation_metric: :class:`~.iMPS.iMPSError`</span>
<span class="sd">        Errors introduced during the conversion.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    - If :attr:`trunc_par.svd_min` is not provided, the truncation threshold</span>
<span class="sd">      defaults to 1e-6.</span>
<span class="sd">    - If :attr:`trunc_par.degeneracy_tol` is not provided, the degeneracy tolerance</span>
<span class="sd">      defaults to 1e-12.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">trunc_par</span> <span class="o">=</span> <span class="n">to_stopping_condition</span><span class="p">(</span><span class="n">trunc_par</span><span class="p">)</span>

    <span class="n">L_short</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">C_short</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">err</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Got correlation matrix of invalid shape </span><span class="si">{</span><span class="n">C_short</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span>
    <span class="k">assert</span> <span class="n">C_short</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">L_short</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">L_short</span><span class="p">),</span> <span class="n">err</span>

    <span class="n">L_long</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">C_long</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">err</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Got correlation matrix of invalid shape </span><span class="si">{</span><span class="n">C_long</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span>
    <span class="k">assert</span> <span class="n">C_long</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">L_long</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">L_long</span><span class="p">),</span> <span class="n">err</span>

    <span class="k">assert</span> <span class="n">L_short</span> <span class="o">+</span> <span class="n">sites_per_cell</span> <span class="o">==</span> <span class="n">L_long</span><span class="p">,</span> <span class="p">(</span>
        <span class="s2">&quot;The given two MPS must differ by one unit cell, got &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">L_long</span><span class="si">}</span><span class="s2"> - </span><span class="si">{</span><span class="n">L_short</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">sites_per_cell</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>

    <span class="c1"># lists for accumulating the tensors and singular values</span>
    <span class="n">tensors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">λs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Reference bipartition in the two chains</span>
    <span class="n">Schmidt_short</span> <span class="o">=</span> <span class="n">SchmidtVectors</span><span class="o">.</span><span class="n">from_correlation_matrix</span><span class="p">(</span>
        <span class="n">C_short</span><span class="p">,</span> <span class="n">cut</span><span class="p">,</span> <span class="n">trunc_par</span><span class="o">=</span><span class="n">trunc_par</span><span class="p">,</span> <span class="n">diag_tol</span><span class="o">=</span><span class="n">diag_tol</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="n">basis</span>
    <span class="p">)</span>
    <span class="n">λs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">normalize_SV</span><span class="p">(</span><span class="n">Schmidt_short</span><span class="o">.</span><span class="n">schmidt_values</span><span class="p">,</span> <span class="n">logger</span><span class="p">))</span>
    <span class="n">Schmidt_long</span> <span class="o">=</span> <span class="n">SchmidtVectors</span><span class="o">.</span><span class="n">from_correlation_matrix</span><span class="p">(</span>
        <span class="n">C_long</span><span class="p">,</span> <span class="n">cut</span><span class="p">,</span> <span class="n">trunc_par</span><span class="o">=</span><span class="n">trunc_par</span><span class="p">,</span> <span class="n">diag_tol</span><span class="o">=</span><span class="n">diag_tol</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="n">basis</span>
    <span class="p">)</span>

    <span class="c1"># Right canonical tensors</span>
    <span class="n">Schmidt</span> <span class="o">=</span> <span class="n">Schmidt_long</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sites_per_cell</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Site </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">sites_per_cell</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">Schmidt_new</span> <span class="o">=</span> <span class="n">Schmidt_short</span>  <span class="c1"># compare with right env of short chain</span>
            <span class="n">λs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">λs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># ensure first and last λ identical</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Schmidt_new</span> <span class="o">=</span> <span class="n">SchmidtVectors</span><span class="o">.</span><span class="n">from_correlation_matrix</span><span class="p">(</span>
                <span class="n">C_long</span><span class="p">,</span>
                <span class="n">cut</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">trunc_par</span><span class="p">,</span>
                <span class="n">which</span><span class="o">=</span><span class="s2">&quot;R&quot;</span><span class="p">,</span>
                <span class="n">diag_tol</span><span class="o">=</span><span class="n">diag_tol</span><span class="p">,</span>
                <span class="n">basis</span><span class="o">=</span><span class="n">basis</span><span class="p">,</span>
                <span class="n">total_parity</span><span class="o">=</span><span class="n">Schmidt_long</span><span class="o">.</span><span class="n">parity</span><span class="p">(),</span>
            <span class="p">)</span>
            <span class="n">λs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">normalize_SV</span><span class="p">(</span><span class="n">Schmidt_new</span><span class="o">.</span><span class="n">schmidt_values</span><span class="p">,</span> <span class="n">logger</span><span class="p">))</span>

        <span class="c1"># compute the tensor</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">MPSTensorData</span><span class="o">.</span><span class="n">from_schmidt_vectors</span><span class="p">(</span><span class="n">Schmidt_new</span><span class="p">,</span> <span class="n">Schmidt</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">)</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">to_npc_array</span><span class="p">()</span>
        <span class="n">tensors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Tensor norm on site </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">npc</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">λs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="mf">0.5</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">logger</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">):</span>
            <span class="c1"># check accuracy of canonical form</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="p">[[</span><span class="s2">&quot;vR&quot;</span><span class="p">,</span> <span class="s2">&quot;p&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;vR*&quot;</span><span class="p">,</span> <span class="s2">&quot;p*&quot;</span><span class="p">]])</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">to_ndarray</span><span class="p">()</span>
            <span class="n">deviation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">e</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)))</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;RMS RC deviation: </span><span class="si">{</span><span class="n">deviation</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">Schmidt</span> <span class="o">=</span> <span class="n">Schmidt_new</span>

    <span class="c1"># Gauge fix first tensor</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">MPSTensorData</span><span class="o">.</span><span class="n">from_schmidt_vectors</span><span class="p">(</span><span class="n">Schmidt_short</span><span class="p">,</span> <span class="n">Schmidt_long</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">)</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">to_npc_array</span><span class="p">()</span>
    <span class="n">C</span><span class="p">,</span> <span class="n">left_unitary</span><span class="p">,</span> <span class="n">left_schmidt</span> <span class="o">=</span> <span class="n">iMPS</span><span class="o">.</span><span class="n">basis_rotation</span><span class="p">(</span>
        <span class="n">C</span><span class="p">,</span>
        <span class="n">Schmidt_short</span><span class="o">.</span><span class="n">schmidt_values</span><span class="p">,</span>
        <span class="n">Schmidt_long</span><span class="o">.</span><span class="n">schmidt_values</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
        <span class="n">unitary_tol</span><span class="o">=</span><span class="n">unitary_tol</span><span class="p">,</span>
        <span class="n">schmidt_tol</span><span class="o">=</span><span class="n">schmidt_tol</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;vR&quot;</span><span class="p">,</span> <span class="s2">&quot;vL&quot;</span><span class="p">])</span>

    <span class="n">iMPS_</span> <span class="o">=</span> <span class="n">networks</span><span class="o">.</span><span class="n">MPS</span><span class="p">(</span>
        <span class="p">[</span><span class="n">fermion_site</span><span class="p">]</span> <span class="o">*</span> <span class="n">sites_per_cell</span><span class="p">,</span> <span class="n">tensors</span><span class="p">,</span> <span class="n">λs</span><span class="p">,</span> <span class="n">bc</span><span class="o">=</span><span class="s2">&quot;infinite&quot;</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="s2">&quot;B&quot;</span>
    <span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">iMPS</span><span class="o">.</span><span class="n">iMPSError</span><span class="p">(</span><span class="n">left_unitary</span><span class="p">,</span> <span class="n">left_schmidt</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">iMPS_</span><span class="p">,</span> <span class="n">error</span></div>



<div class="viewcode-block" id="H_to_MPS">
<a class="viewcode-back" href="../../reference/pfaffian.html#temfpy.pfaffian.H_to_MPS">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">H_to_MPS</span><span class="p">(</span>
    <span class="n">H</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">trunc_par</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="n">StoppingCondition</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">basis</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">diag_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_DIAG_TOL</span><span class="p">,</span>
    <span class="n">ortho_center</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">networks</span><span class="o">.</span><span class="n">MPS</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;MPS representation of a Nambu mean-field ground state from its single particle Hamiltonian.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    H:</span>
<span class="sd">        Single particle Hamiltonian in the basis indicated by ``basis``.</span>
<span class="sd">    trunc_par:</span>
<span class="sd">        Specifies which Schmidt states should be kept.</span>

<span class="sd">        Must be either a :class:`~temfpy.schmidt_utils.StoppingCondition` object</span>
<span class="sd">        or a dictionary with matching keys.</span>

<span class="sd">        Only specify the field ``sectors`` if you know what you are doing!!</span>
<span class="sd">    basis:</span>
<span class="sd">        &quot;M&quot; or &quot;C&quot;, indicates whether the Hamiltonian is given</span>
<span class="sd">        in the Majorana or the complex-fermion basis.</span>
<span class="sd">    ortho_center:</span>
<span class="sd">        Orthogonality centre of the mixed canonical MPS.</span>
<span class="sd">        Midpoint of the chain by default.</span>
<span class="sd">    diag_tol:</span>
<span class="sd">        Largest allowed offdiagonal matrix element in diagonalised / SVD</span>
<span class="sd">        correlation submatrices before an error is raised.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        The wave function as a TeNPy :class:`~tenpy.networks.mps.MPS` object.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    - If :attr:`trunc_par.svd_min` is not provided, the truncation threshold</span>
<span class="sd">      defaults to 1e-6.</span>
<span class="sd">    - If :attr:`trunc_par.degeneracy_tol` is not provided, the degeneracy tolerance</span>
<span class="sd">      defaults to 1e-12.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">correlation_matrix</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">basis</span><span class="si">}</span><span class="s2">-&gt;</span><span class="si">{</span><span class="n">basis</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">C_to_MPS</span><span class="p">(</span>
        <span class="n">C</span><span class="p">,</span>
        <span class="n">trunc_par</span><span class="p">,</span>
        <span class="n">basis</span><span class="o">=</span><span class="n">basis</span><span class="p">,</span>
        <span class="n">diag_tol</span><span class="o">=</span><span class="n">diag_tol</span><span class="p">,</span>
        <span class="n">ortho_center</span><span class="o">=</span><span class="n">ortho_center</span><span class="p">,</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="H_to_iMPS">
<a class="viewcode-back" href="../../reference/pfaffian.html#temfpy.pfaffian.H_to_iMPS">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">H_to_iMPS</span><span class="p">(</span>
    <span class="n">H_short</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">H_long</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">trunc_par</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="n">StoppingCondition</span><span class="p">,</span>
    <span class="n">sites_per_cell</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">cut</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">basis</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">diag_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_DIAG_TOL</span><span class="p">,</span>
    <span class="n">unitary_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">iMPS</span><span class="o">.</span><span class="n">_UNITARY_TOL</span><span class="p">,</span>
    <span class="n">schmidt_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">iMPS</span><span class="o">.</span><span class="n">_SCHMIDT_TOL</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">networks</span><span class="o">.</span><span class="n">MPS</span><span class="p">,</span> <span class="n">iMPS</span><span class="o">.</span><span class="n">iMPSError</span><span class="p">]:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;iMPS representation of a Nambu mean-field state from single particle hamiltonians.</span>

<span class="sd">    It is expected that the two single-particle Hamiltonians describe two </span>
<span class="sd">    translation-invariant systems that differ by one repeating unit cell.</span>

<span class="sd">    The method is analogous to :func:`.iMPS.MPS_to_iMPS`, with two differences:</span>

<span class="sd">    - No explicit MPS tensors are computed for the environment of the iMPS unit</span>
<span class="sd">      cell. Instead, the Schmidt vector overlaps needed for gauge fixing are</span>
<span class="sd">      computed using the Pfaffian state overlap formulas implemented in</span>
<span class="sd">      :class:`MPSTensorData`.</span>
<span class="sd">    - The rightmost tensor is computed directly using the right Schmidt vectors</span>
<span class="sd">      of the shorter chain. This means that no separate :class:`~.iMPS.iMPSError`\ s</span>
<span class="sd">      are returned for the right side.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    H_short:</span>
<span class="sd">        Single particle Hamiltonian in the basis indicated by ``basis``</span>
<span class="sd">        for the shorter chain.</span>
<span class="sd">    H_long:</span>
<span class="sd">        Single particle Hamiltonian in the basis indicated by ``basis``</span>
<span class="sd">        for the longer chain.</span>
<span class="sd">    trunc_par:</span>
<span class="sd">        Specifies which Schmidt states should be kept.</span>

<span class="sd">        Must be either a :class:`~temfpy.schmidt_utils.StoppingCondition` object</span>
<span class="sd">        or a dictionary with matching keys.</span>

<span class="sd">        Only specify the field ``sectors`` if you know what you are doing!!</span>
<span class="sd">    sites_per_cell:</span>
<span class="sd">        Size of the iMPS unit cell.</span>
<span class="sd">    cut:</span>
<span class="sd">        First site of the repeating unit cell in ``H_long``.</span>
<span class="sd">    basis:</span>
<span class="sd">        &quot;M&quot; or &quot;C&quot;, indicates whether the Hamiltonian is given</span>
<span class="sd">        in the Majorana or the complex-fermion basis.</span>
<span class="sd">    diag_tol:</span>
<span class="sd">        Largest allowed offdiagonal matrix element in diagonalised / SVD</span>
<span class="sd">        correlation submatrices before an error is raised.</span>
<span class="sd">    unitary_tol:</span>
<span class="sd">        Maximum deviation of the gauge rotation matrices from unitarity</span>
<span class="sd">        before a warning is raised.</span>
<span class="sd">    schmidt_tol:</span>
<span class="sd">        Maximum mixing of unequal Schmidt values by the gauge rotation matrices</span>
<span class="sd">        before a warning is raised.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    iMPS: :class:`~tenpy.networks.mps.MPS`</span>
<span class="sd">        iMPS with unit cell size ``sites_per_cell``, constructed from the</span>
<span class="sd">        additional unit cell of ``mps_long``.</span>
<span class="sd">    validation_metric: :class:`~.iMPS.iMPSError`</span>
<span class="sd">        Errors introduced during the conversion.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    - If :attr:`trunc_par.svd_min` is not provided, the truncation threshold</span>
<span class="sd">      defaults to 1e-6.</span>
<span class="sd">    - If :attr:`trunc_par.degeneracy_tol` is not provided, the degeneracy tolerance</span>
<span class="sd">      defaults to 1e-12.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        
    <span class="n">C_short</span> <span class="o">=</span> <span class="n">correlation_matrix</span><span class="p">(</span><span class="n">H_short</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">basis</span><span class="si">}</span><span class="s2">-&gt;</span><span class="si">{</span><span class="n">basis</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">C_long</span> <span class="o">=</span> <span class="n">correlation_matrix</span><span class="p">(</span><span class="n">H_long</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">basis</span><span class="si">}</span><span class="s2">-&gt;</span><span class="si">{</span><span class="n">basis</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">C_to_iMPS</span><span class="p">(</span>
        <span class="n">C_short</span><span class="p">,</span>
        <span class="n">C_long</span><span class="p">,</span>
        <span class="n">trunc_par</span><span class="p">,</span>
        <span class="n">sites_per_cell</span><span class="p">,</span>
        <span class="n">cut</span><span class="p">,</span>
        <span class="n">basis</span><span class="o">=</span><span class="n">basis</span><span class="p">,</span>
        <span class="n">diag_tol</span><span class="o">=</span><span class="n">diag_tol</span><span class="p">,</span>
        <span class="n">unitary_tol</span><span class="o">=</span><span class="n">unitary_tol</span><span class="p">,</span>
        <span class="n">schmidt_tol</span><span class="o">=</span><span class="n">schmidt_tol</span><span class="p">,</span>
    <span class="p">)</span></div>


</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Simon Hans Hille, Attila Szabó.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>