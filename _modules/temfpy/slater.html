

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>temfpy.slater &mdash; TeMFpy 2025 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=9edc463e" />
      <link rel="stylesheet" type="text/css" href="../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=b9ceff23" />

  
    <link rel="shortcut icon" href="../../_static/favicon.svg"/>
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=cb975c41"></script>
      <script src="../../_static/doctools.js?v=fd6eb6e6"></script>
      <script src="../../_static/sphinx_highlight.js?v=6ffebe34"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            TeMFpy
              <img src="../../_static/logo.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/contribute.html">Contributorsâ€™ guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../getting_started/contribute.html#best-practices">Best practices</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../getting_started/contribute.html#discuss-before-you-contribute">Discuss before you contribute</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../getting_started/contribute.html#no-giant-prs">No giant PRs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../getting_started/contribute.html#document-your-changes">Document your changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../getting_started/contribute.html#coding-style">Coding style</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../getting_started/contribute.html#how-to-submit-a-pr">How to submit a PR</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/citing.html">Citing TeMFpy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/examples.html">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../examples/gutzwiller.html">gutzwiller.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/iMPS.html">iMPS.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/iMPS_pfaffian.html">iMPS_pfaffian.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/iMPS_slater.html">iMPS_slater.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/pfaffian.html">pfaffian.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples/slater.html">slater.py</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#temfpy-0-3-in-development">TeMFpy 0.3 (In development)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#api-breaking-changes">API breaking changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#new-features">New features</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#bug-fixes">Bug fixes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#temfpy-0-2-1-28-january-2026">TeMFpy 0.2.1 (28 January 2026)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../changelog.html#id1">Bug fixes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#temfpy-0-2-23-january-2026">TeMFpy 0.2 (23 January 2026)</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../reference/slater.html">slater</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../reference/slater.html#classes">Classes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes"><code class="docutils literal notranslate"><span class="pre">SchmidtModes</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.e"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.e</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.vL"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.vL</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.vR"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.vR</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.ixL"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.ixL</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.ixR"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.ixR</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.nL"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.nL</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.nR"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.nR</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.n_fermion"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.n_fermion</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.n_entangled"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.n_entangled</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.size"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.size()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.n_filled"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.n_filled()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.vL_entangled"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.vL_entangled</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.vR_entangled"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.vR_entangled</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.mode_vectors"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.mode_vectors()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.eigenvalues"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.eigenvalues()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.singular_values"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.singular_values</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.from_correlation_matrix"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.from_correlation_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.e_ratio"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.e_ratio</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.embed_subsets"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.embed_subsets()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtModes.schmidt_values"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.schmidt_values()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.modes"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.modes</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.left_sets"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.left_sets</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.right_sets"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.right_sets</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.schmidt_values"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.schmidt_values</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.idx_L"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.idx_L</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.n_schmidt"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.n_schmidt</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.n_entangled"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.n_entangled</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.nL"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.nL</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.nR"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.nR</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.n_fermion"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.n_fermion</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.size"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.size()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.vL"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.vL</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.vR"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.vR</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.mode_vectors"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.mode_vectors()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.sets"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.sets()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.from_schmidt_modes"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.from_schmidt_modes()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.from_correlation_matrix"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.from_correlation_matrix()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.MPSTensorData"><code class="docutils literal notranslate"><span class="pre">MPSTensorData</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.MPSTensorData.mode"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.mode</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.MPSTensorData.physical_leg"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.physical_leg</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.MPSTensorData.det_always"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.det_always</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.MPSTensorData.sometimes_matrix"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.sometimes_matrix</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.MPSTensorData.idx_bra"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.idx_bra</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.MPSTensorData.idx_ket"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.idx_ket</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.MPSTensorData.new_sets_bra"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.new_sets_bra</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.MPSTensorData.new_sets_ket"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.new_sets_ket</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.MPSTensorData.qtotal"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.qtotal</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.MPSTensorData.idx_physical"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.idx_physical</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.MPSTensorData.from_schmidt_vectors"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.from_schmidt_vectors()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.MPSTensorData.to_npc_array"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.to_npc_array()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/slater.html#functions">Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.correlation_matrix"><code class="docutils literal notranslate"><span class="pre">correlation_matrix()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.spinful_correlation_matrix"><code class="docutils literal notranslate"><span class="pre">spinful_correlation_matrix()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.C_to_MPS"><code class="docutils literal notranslate"><span class="pre">C_to_MPS()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.C_to_iMPS"><code class="docutils literal notranslate"><span class="pre">C_to_iMPS()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.H_to_MPS"><code class="docutils literal notranslate"><span class="pre">H_to_MPS()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/slater.html#temfpy.slater.H_to_iMPS"><code class="docutils literal notranslate"><span class="pre">H_to_iMPS()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/pfaffian.html">pfaffian</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../reference/pfaffian.html#representing-nambu-correlation-matrices">Representing Nambu correlation matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/pfaffian.html#classes">Classes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes"><code class="docutils literal notranslate"><span class="pre">SchmidtModes</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.nL"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.nL</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.nR"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.nR</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.e"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.e</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.vL"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.vL</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.vR"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.vR</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.pL"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.pL</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.pR"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.pR</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.parity"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.parity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.n_entangled"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.n_entangled</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.size"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.size()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.vL_entangled"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.vL_entangled</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.vR_entangled"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.vR_entangled</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.mode_vectors"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.mode_vectors()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.eigenvalues"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.eigenvalues()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.singular_values"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.singular_values</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.from_correlation_matrix"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.from_correlation_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.e_ratio"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.e_ratio</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.embed_subsets"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.embed_subsets()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtModes.schmidt_values"><code class="docutils literal notranslate"><span class="pre">SchmidtModes.schmidt_values()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.modes"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.modes</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.left_sets"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.left_sets</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.right_sets"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.right_sets</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.schmidt_values"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.schmidt_values</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.idx_n"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.idx_n</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.idx_parity"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.idx_parity</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.n_schmidt"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.n_schmidt</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.n_entangled"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.n_entangled</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.nL"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.nL</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.nR"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.nR</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.size"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.size()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.vL"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.vL</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.vR"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.vR</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.mode_vectors"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.mode_vectors()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.pL"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.pL</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.pR"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.pR</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.parity"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.parity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.sets"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.sets()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.from_schmidt_modes"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.from_schmidt_modes()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.SchmidtVectors.from_correlation_matrix"><code class="docutils literal notranslate"><span class="pre">SchmidtVectors.from_correlation_matrix()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData"><code class="docutils literal notranslate"><span class="pre">MPSTensorData</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData.mode"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.mode</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData.norm"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.norm</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData.pfaffian_matrix"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.pfaffian_matrix</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData.labels"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.labels</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData.qtotal"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.qtotal</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData.leg_bra"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.leg_bra</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData.new_sets_bra"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.new_sets_bra</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData.idx_n_bra"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.idx_n_bra</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData.leg_idx_bra"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.leg_idx_bra</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData.leg_ket"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.leg_ket</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData.new_sets_ket"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.new_sets_ket</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData.idx_n_ket"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.idx_n_ket</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData.from_schmidt_vectors"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.from_schmidt_vectors()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.MPSTensorData.to_npc_array"><code class="docutils literal notranslate"><span class="pre">MPSTensorData.to_npc_array()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/pfaffian.html#high-level-functions">High-level functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.correlation_matrix"><code class="docutils literal notranslate"><span class="pre">correlation_matrix()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.parity"><code class="docutils literal notranslate"><span class="pre">parity()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.C_to_MPS"><code class="docutils literal notranslate"><span class="pre">C_to_MPS()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.C_to_iMPS"><code class="docutils literal notranslate"><span class="pre">C_to_iMPS()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.H_to_MPS"><code class="docutils literal notranslate"><span class="pre">H_to_MPS()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.H_to_iMPS"><code class="docutils literal notranslate"><span class="pre">H_to_iMPS()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/pfaffian.html#helper-functions">Helper functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.vector_C2M"><code class="docutils literal notranslate"><span class="pre">vector_C2M()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.vector_M2C"><code class="docutils literal notranslate"><span class="pre">vector_M2C()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.matrix_C2M"><code class="docutils literal notranslate"><span class="pre">matrix_C2M()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.matrix_M2C"><code class="docutils literal notranslate"><span class="pre">matrix_M2C()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.assert_nambu"><code class="docutils literal notranslate"><span class="pre">assert_nambu()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.assert_nambu_hamiltonian"><code class="docutils literal notranslate"><span class="pre">assert_nambu_hamiltonian()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/pfaffian.html#temfpy.pfaffian.assert_nambu_correlation"><code class="docutils literal notranslate"><span class="pre">assert_nambu_correlation()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/iMPS.html">iMPS</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../reference/iMPS.html#temfpy.iMPS.MPS_to_iMPS"><code class="docutils literal notranslate"><span class="pre">MPS_to_iMPS()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/iMPS.html#temfpy.iMPS.overlap_schmidt"><code class="docutils literal notranslate"><span class="pre">overlap_schmidt()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/iMPS.html#temfpy.iMPS.basis_rotation"><code class="docutils literal notranslate"><span class="pre">basis_rotation()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/iMPS.html#temfpy.iMPS.iMPSError"><code class="docutils literal notranslate"><span class="pre">iMPSError</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/iMPS.html#temfpy.iMPS.iMPSError.left_unitary"><code class="docutils literal notranslate"><span class="pre">iMPSError.left_unitary</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/iMPS.html#temfpy.iMPS.iMPSError.left_schmidt"><code class="docutils literal notranslate"><span class="pre">iMPSError.left_schmidt</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/iMPS.html#temfpy.iMPS.iMPSError.right_unitary"><code class="docutils literal notranslate"><span class="pre">iMPSError.right_unitary</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/iMPS.html#temfpy.iMPS.iMPSError.right_schmidt"><code class="docutils literal notranslate"><span class="pre">iMPSError.right_schmidt</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/iMPS.html#temfpy.iMPS.iMPSError.left_total"><code class="docutils literal notranslate"><span class="pre">iMPSError.left_total</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/iMPS.html#temfpy.iMPS.iMPSError.right_total"><code class="docutils literal notranslate"><span class="pre">iMPSError.right_total</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/iMPS.html#temfpy.iMPS.iMPSError.total_error"><code class="docutils literal notranslate"><span class="pre">iMPSError.total_error</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/gutzwiller.html">gutzwiller</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../reference/gutzwiller.html#gutzwiller-projections-of-abrikosov-fermions">Gutzwiller projections of Abrikosov fermions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/gutzwiller.html#temfpy.gutzwiller.abrikosov"><code class="docutils literal notranslate"><span class="pre">abrikosov()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/gutzwiller.html#temfpy.gutzwiller.abrikosov_ph"><code class="docutils literal notranslate"><span class="pre">abrikosov_ph()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/gutzwiller.html#helper-functions">Helper functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/gutzwiller.html#temfpy.gutzwiller.parity_mask"><code class="docutils literal notranslate"><span class="pre">parity_mask()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/gutzwiller.html#temfpy.gutzwiller.number_mask"><code class="docutils literal notranslate"><span class="pre">number_mask()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/testing.html">testing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../reference/testing.html#temfpy.testing.TEST_ACTION"><code class="docutils literal notranslate"><span class="pre">TEST_ACTION</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/testing.html#testing-functions">Testing functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/testing.html#temfpy.testing.assert_allclose"><code class="docutils literal notranslate"><span class="pre">assert_allclose()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/testing.html#temfpy.testing.assert_array_less"><code class="docutils literal notranslate"><span class="pre">assert_array_less()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/testing.html#temfpy.testing.check_schmidt_decomposition"><code class="docutils literal notranslate"><span class="pre">check_schmidt_decomposition()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/testing.html#temfpy.testing.ComparisonWarning"><code class="docutils literal notranslate"><span class="pre">ComparisonWarning</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/schmidt_utils.html">schmidt_utils</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../reference/schmidt_utils.html#temfpy.schmidt_utils.StoppingCondition"><code class="docutils literal notranslate"><span class="pre">StoppingCondition</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/schmidt_utils.html#temfpy.schmidt_utils.StoppingCondition.sectors"><code class="docutils literal notranslate"><span class="pre">StoppingCondition.sectors</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/schmidt_utils.html#temfpy.schmidt_utils.StoppingCondition.chi_max"><code class="docutils literal notranslate"><span class="pre">StoppingCondition.chi_max</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/schmidt_utils.html#temfpy.schmidt_utils.StoppingCondition.svd_min"><code class="docutils literal notranslate"><span class="pre">StoppingCondition.svd_min</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/schmidt_utils.html#temfpy.schmidt_utils.StoppingCondition.degeneracy_tol"><code class="docutils literal notranslate"><span class="pre">StoppingCondition.degeneracy_tol</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/schmidt_utils.html#temfpy.schmidt_utils.StoppingCondition.__call__"><code class="docutils literal notranslate"><span class="pre">StoppingCondition.__call__()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/schmidt_utils.html#temfpy.schmidt_utils.StoppingCondition.truncate"><code class="docutils literal notranslate"><span class="pre">StoppingCondition.truncate()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/schmidt_utils.html#temfpy.schmidt_utils.lowest_sums"><code class="docutils literal notranslate"><span class="pre">lowest_sums()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/utils.html">utils</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../reference/utils.html#temfpy.utils.HT"><code class="docutils literal notranslate"><span class="pre">HT()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/utils.html#temfpy.utils.n_slice"><code class="docutils literal notranslate"><span class="pre">n_slice()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/utils.html#temfpy.utils.block_svd"><code class="docutils literal notranslate"><span class="pre">block_svd()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/utils.html#temfpy.utils.normalize_SV"><code class="docutils literal notranslate"><span class="pre">normalize_SV()</span></code></a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">TeMFpy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">temfpy.slater</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for temfpy.slater</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (C) TeMFPy Developers, MIT license</span>
<span class="sd">&quot;&quot;&quot;Tools for converting Slater determinants into matrix product states (MPS).&quot;&quot;&quot;</span>

<span class="c1"># Standard library</span>
<span class="c1"># ---------------</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Literal</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>

<span class="c1"># Third-party libraries</span>
<span class="c1"># ---------------</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy.linalg</span><span class="w"> </span><span class="kn">import</span> <span class="n">eigh</span><span class="p">,</span> <span class="n">det</span><span class="p">,</span> <span class="n">inv</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">tenpy.linalg.np_conserved</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">npc</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tenpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">networks</span>

<span class="c1"># Local imports</span>
<span class="c1"># -------------</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.schmidt_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">lowest_sums</span><span class="p">,</span> <span class="n">StoppingCondition</span><span class="p">,</span> <span class="n">to_stopping_condition</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">n_slice</span><span class="p">,</span> <span class="n">HT</span><span class="p">,</span> <span class="n">block_svd</span><span class="p">,</span> <span class="n">normalize_SV</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.testing</span><span class="w"> </span><span class="kn">import</span> <span class="n">assert_allclose</span><span class="p">,</span> <span class="n">check_schmidt_decomposition</span><span class="p">,</span> <span class="n">_DIAG_TOL</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">iMPS</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="c1">#### TENPY BINDINGS ####</span>
<span class="c1">#### -------------- ####</span>
<span class="n">fermion_site</span> <span class="o">=</span> <span class="n">networks</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">FermionSite</span><span class="p">()</span>
<span class="sd">&quot;&quot;&quot;Lattice site prototype for the number-conserving fermion MPS.&quot;&quot;&quot;</span>
<span class="n">fermion_leg</span> <span class="o">=</span> <span class="n">fermion_site</span><span class="o">.</span><span class="n">leg</span>
<span class="sd">&quot;&quot;&quot;:class:`~tenpy.linalg.charges.LegCharge` for the single-site Hilbert space</span>
<span class="sd">of the number-conserving fermion MPS.&quot;&quot;&quot;</span>
<span class="n">chinfo</span> <span class="o">=</span> <span class="n">fermion_leg</span><span class="o">.</span><span class="n">chinfo</span>
<span class="sd">&quot;&quot;&quot;:class:`~tenpy.linalg.charges.ChargeInfo` for fermion number conservation.&quot;&quot;&quot;</span>


<span class="c1">#### SCHMIDT ORBITALS ####</span>
<span class="c1">#### ---------------- ####</span>
<div class="viewcode-block" id="SchmidtModes">
<a class="viewcode-back" href="../../reference/slater.html#temfpy.slater.SchmidtModes">[docs]</a>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SchmidtModes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mean-field orbitals that generate the Schmidt vectors of a Slater determinant.&quot;&quot;&quot;</span>

    <span class="n">e</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;array (:attr:`n_entangled`,) -- </span>
<span class="sd">    Entangled eigenvalues of the left-left block of the correlation matrix,</span>
<span class="sd">    in decreasing order.&quot;&quot;&quot;</span>
    <span class="n">vL</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;array (:attr:`nL`, :attr:`nL`) --</span>
<span class="sd">    Eigenvectors of the left-left block of the correlation matrix, if computed.</span>

<span class="sd">    The eigenvectors are the columns of the matrix in the order</span>

<span class="sd">    - filled orbitals (eigenvalue 1);</span>
<span class="sd">    - entangled orbitals (eigenvalue between 0 and 1, decreasing order);</span>
<span class="sd">    - empty orbitals (eigenvalue 0).</span>

<span class="sd">    In particular, the eigenvalues corresponding to</span>
<span class="sd">    ``v_LE = vL[:, ixL[&quot;entangled&quot;]]`` are given in order by ``e``.</span>

<span class="sd">    Note that the entangled orbital vectors ``v_LE`` are also left singular vectors</span>
<span class="sd">    of the offdiagonal block :math:`C^{LR}` of the correlation matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vR</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;array (:attr:`nR`, :attr:`nR`) --</span>
<span class="sd">    Eigenvectors of the right-right block of the correlation matrix, if computed. </span>

<span class="sd">    The eigenvectors are the columns of the matrix in the order</span>

<span class="sd">    - empty orbitals (eigenvalue 0);</span>
<span class="sd">    - entangled orbitals (eigenvalue between 0 and 1, decreasing order);</span>
<span class="sd">    - filled orbitals (eigenvalue 1).</span>

<span class="sd">    In particular, the eigenvalues corresponding to</span>
<span class="sd">    ``v_RE = vR[:, ixR[&quot;entangled&quot;]]`` are given in order by ``1-e[::-1]``.</span>

<span class="sd">    Note that the entangled orbital vectors ``v_RE`` are also right singular</span>
<span class="sd">    vectors of the offdiagonal block :math:`C^{LR}` of the correlation matrix.</span>
<span class="sd">    </span>
<span class="sd">    If both :attr:`vL` and :attr:`vR` are computed, the singular vectors</span>
<span class="sd">    ``v_LE[:, i]`` and ``v_RE[:, n_entangled-1-i]`` correspond to each other,</span>
<span class="sd">    with eigenvalues :math:`\lambda_i` and :math:`1-\lambda_i`, so that the</span>
<span class="sd">    SVD of :math:`C^{LR}` is</span>

<span class="sd">    .. math::</span>
<span class="sd">        C^{LR} = \sum_{i=0}^{n_E-1} \sqrt{\lambda_i (1-\lambda_i)} \;</span>
<span class="sd">                                    v_{L,E,i} \; v_{R,E,n_E-1-i}^\dagger.</span>

<span class="sd">    However, to better handle fermion anticommutation, the entangled orbitals</span>
<span class="sd">    at odd indices include an additional negative sign.&quot;&quot;&quot;</span>
    <span class="n">ixL</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">slice</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Maps the labels ``&quot;empty&quot;``, ``&quot;filled&quot;``, ``&quot;entangled&quot;`` to column</span>
<span class="sd">    slices of the corresponding orbitals in :attr:`vL`, if that is computed.&quot;&quot;&quot;</span>
    <span class="n">ixR</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">slice</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Maps the labels ``&quot;empty&quot;``, ``&quot;filled&quot;``, ``&quot;entangled&quot;`` to column</span>
<span class="sd">    slices of the corresponding orbitals in :attr:`vR`, if that is computed.&quot;&quot;&quot;</span>
    <span class="n">nL</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Size of the left half of the system.&quot;&quot;&quot;</span>
    <span class="n">nR</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Size of the right half of the system.&quot;&quot;&quot;</span>
    <span class="n">n_fermion</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Number of fermions in the mean-field state.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">err</span> <span class="o">=</span> <span class="s2">&quot;`ixL` and `vL` must be specified together&quot;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vL</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ixL</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">),</span> <span class="n">err</span>
        <span class="n">err</span> <span class="o">=</span> <span class="s2">&quot;`ixR` and `vR` must be specified together&quot;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vR</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ixR</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">),</span> <span class="n">err</span>
        <span class="n">err</span> <span class="o">=</span> <span class="s2">&quot;Must specify at least one of `vL`, `vR`&quot;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vL</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vR</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">),</span> <span class="n">err</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vL</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">nL</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vL</span><span class="p">),</span> <span class="s2">&quot;`nL` must match the size of `vL`&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vR</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">nR</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vR</span><span class="p">),</span> <span class="s2">&quot;`nR` must match the size of `vR`&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">n_entangled</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of entangled orbitals.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">e</span><span class="o">.</span><span class="n">size</span>

<div class="viewcode-block" id="SchmidtModes.size">
<a class="viewcode-back" href="../../reference/slater.html#temfpy.slater.SchmidtModes.size">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;T&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Size of the specified half or the whole of the system.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        which:</span>
<span class="sd">            Either &quot;L&quot; for left or &quot;R&quot; for right side</span>
<span class="sd">            or &quot;T&quot; (default) for total size.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            :attr:`nL`, :attr:`nR`, or their sum, depending on ``which``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">which_</span> <span class="o">=</span> <span class="n">which</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">which_</span> <span class="o">==</span> <span class="s2">&quot;L&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nL</span>
        <span class="k">elif</span> <span class="n">which_</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nR</span>
        <span class="k">elif</span> <span class="n">which_</span> <span class="o">==</span> <span class="s2">&quot;T&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nL</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nR</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`which` must start with L, R, or T, got &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">which</span><span class="p">))</span></div>


<div class="viewcode-block" id="SchmidtModes.n_filled">
<a class="viewcode-back" href="../../reference/slater.html#temfpy.slater.SchmidtModes.n_filled">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">n_filled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of filled orbitals on the specified half of the system.</span>

<span class="sd">        Based on :attr:`vL` or :attr:`vR` if they exist, otherwise inferred from</span>
<span class="sd">        :attr:`n_fermion` and the number of entangled and filled orbitals</span>
<span class="sd">        on the other side.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        which:</span>
<span class="sd">            Whether to return the number of filled orbitals</span>
<span class="sd">            to the left (&quot;L&quot;) or the right (&quot;R&quot;).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            Number of filled orbitals on the specified side.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">which_</span> <span class="o">=</span> <span class="n">which</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">which_</span> <span class="o">==</span> <span class="s2">&quot;L&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ixL</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">n_slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ixL</span><span class="p">[</span><span class="s2">&quot;filled&quot;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_fermion</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_entangled</span> <span class="o">-</span> <span class="n">n_slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ixR</span><span class="p">[</span><span class="s2">&quot;filled&quot;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">which_</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ixR</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">n_slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ixR</span><span class="p">[</span><span class="s2">&quot;filled&quot;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_fermion</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_entangled</span> <span class="o">-</span> <span class="n">n_slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ixL</span><span class="p">[</span><span class="s2">&quot;filled&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`which` must start with L or R, got &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">which</span><span class="p">))</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">vL_entangled</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Entangled left Schmidt mode orbitals, if computed.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vL</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">vL</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ixL</span><span class="p">[</span><span class="s2">&quot;entangled&quot;</span><span class="p">]]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">vR_entangled</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Entangled right Schmidt mode orbitals, if computed.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vR</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">vR</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ixR</span><span class="p">[</span><span class="s2">&quot;entangled&quot;</span><span class="p">]]</span>

<div class="viewcode-block" id="SchmidtModes.mode_vectors">
<a class="viewcode-back" href="../../reference/slater.html#temfpy.slater.SchmidtModes.mode_vectors">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mode_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">entangled</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the Schmidt mode orbitals on the specified side.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        which:</span>
<span class="sd">            Either &quot;L&quot; for left or &quot;R&quot; for right side.</span>
<span class="sd">        entangled:</span>
<span class="sd">            Whether to return the entangled (:obj:`True`) or</span>
<span class="sd">            all (:obj:`False`, default) eigenvectors.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            Either :attr:`vL` or :attr:`vR`, depending on ``which``,</span>
<span class="sd">            truncated to entangled modes if ``entangled``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">which_</span> <span class="o">=</span> <span class="n">which</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">which_</span> <span class="o">==</span> <span class="s2">&quot;L&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vL_entangled</span> <span class="k">if</span> <span class="n">entangled</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">vL</span>
        <span class="k">elif</span> <span class="n">which_</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vR_entangled</span> <span class="k">if</span> <span class="n">entangled</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">vR</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`which` must start with L or R, got &quot;</span> <span class="o">+</span> <span class="n">which</span><span class="p">)</span></div>


<div class="viewcode-block" id="SchmidtModes.eigenvalues">
<a class="viewcode-back" href="../../reference/slater.html#temfpy.slater.SchmidtModes.eigenvalues">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">eigenvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">entangled</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the Schmidt mode eigenvalues on the specified side.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        which:</span>
<span class="sd">            Either &quot;L&quot; for left or &quot;R&quot; for right side.</span>
<span class="sd">        entangled:</span>
<span class="sd">            Whether to return the entangled (:obj:`True`) or</span>
<span class="sd">            all (:obj:`False`, default) eigenvalues.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            The eigenvalues corresponding to :meth:`mode_vectors`</span>
<span class="sd">            with the same parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">which_</span> <span class="o">=</span> <span class="n">which</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">which_</span> <span class="o">==</span> <span class="s2">&quot;L&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vL</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">e</span>
            <span class="k">if</span> <span class="n">entangled</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">e</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vL</span><span class="p">))</span>
                <span class="n">E</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ixL</span><span class="p">[</span><span class="s2">&quot;filled&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">E</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ixL</span><span class="p">[</span><span class="s2">&quot;entangled&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">e</span>
                <span class="k">return</span> <span class="n">E</span>
        <span class="k">elif</span> <span class="n">which_</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vR</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">e</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">e</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">entangled</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">e</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vR</span><span class="p">))</span>
                <span class="n">E</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ixR</span><span class="p">[</span><span class="s2">&quot;filled&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">E</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ixR</span><span class="p">[</span><span class="s2">&quot;entangled&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">e</span>
                <span class="k">return</span> <span class="n">E</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`which` must start with L or R, got &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">which</span><span class="p">))</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">singular_values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Singular values of the offdiagonal correlation matrix blocks.</span>

<span class="sd">        If :attr:`vL_entangled` and :attr:`vR_entangled` are both known, satisfies</span>

<span class="sd">        .. code::</span>

<span class="sd">            C_LR == vL_entangled @ diag(S) @ vR_entangled[:, ::-1].T.conj()</span>

<span class="sd">        Otherwise, :obj:`None`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vL</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vR</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">SV</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">e</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">e</span><span class="p">))</span> <span class="o">**</span> <span class="mf">0.5</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">SV</span><span class="o">.</span><span class="n">size</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># anticommutation signs on right SV</span>
        <span class="k">return</span> <span class="n">SV</span> <span class="o">*</span> <span class="n">sign</span>

<div class="viewcode-block" id="SchmidtModes.from_correlation_matrix">
<a class="viewcode-back" href="../../reference/slater.html#temfpy.slater.SchmidtModes.from_correlation_matrix">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_correlation_matrix</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="s2">&quot;SchmidtModes&quot;</span><span class="p">],</span>
        <span class="n">C</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">trunc_par</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="n">StoppingCondition</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">which</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;LR&quot;</span><span class="p">,</span>
        <span class="n">diag_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_DIAG_TOL</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;SchmidtModes&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;:class:`~SchmidtModes` of a mean-field state with correlation matrix ``C``</span>
<span class="sd">        for an entanglement cut between sites ``x-1`` and ``x`` (zero-indexed).</span>

<span class="sd">        We start by diagonalising the respective diagonal blocks.</span>
<span class="sd">        The eigenvectors give the Schmidt modes, the eigenvalues their</span>
<span class="sd">        relative weight in the entangled mode. We only treat modes with</span>
<span class="sd">        eigenvalues away from 0 or 1 by at least :attr:`trunc_par.svd_min`</span>
<span class="sd">        `squared` as entangled, as only these can contribute to a Schmidt value</span>
<span class="sd">        less than :attr:`trunc_par.svd_min`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        C:</span>
<span class="sd">            The correlation matrix, :math:`C_{ij} = \langle c_j^\dagger c_i\rangle`.</span>
<span class="sd">        x:</span>
<span class="sd">            Position of the entanglement cut.</span>
<span class="sd">        trunc_par:</span>
<span class="sd">            Which Schmidt modes should be kept as entangled.</span>

<span class="sd">            Must be either a :class:`~temfpy.schmidt_utils.StoppingCondition` object</span>
<span class="sd">            or a dictionary with matching keys.</span>
<span class="sd">        which:</span>
<span class="sd">            Whether to return left and/or right Schmidt modes.</span>

<span class="sd">            Must be a combination of ``&quot;L&quot;`` and ``&quot;R&quot;``.</span>
<span class="sd">        diag_tol:</span>
<span class="sd">            If ``which == &quot;LR&quot;``, largest allowed offdiagonal matrix element in</span>
<span class="sd">            diagonalised / SVD correlation submatrices before an error is</span>
<span class="sd">            raised.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        - If :attr:`trunc_par.svd_min` is not provided, a default of 1e-6</span>
<span class="sd">          (i.e., a truncation threshold of 1e-12) is used.</span>
<span class="sd">        - If :attr:`trunc_par.degeneracy_tol` is not provided, the degeneracy tolerance</span>
<span class="sd">          defaults to 1e-12.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trunc_par</span> <span class="o">=</span> <span class="n">to_stopping_condition</span><span class="p">(</span><span class="n">trunc_par</span><span class="p">)</span>
        <span class="n">cutoff</span> <span class="o">=</span> <span class="n">trunc_par</span><span class="o">.</span><span class="n">svd_min</span><span class="o">**</span><span class="mi">2</span>  <span class="c1"># eigenvalues -&gt; squared Schmidt values</span>

        <span class="n">which</span> <span class="o">=</span> <span class="n">which</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="n">err</span> <span class="o">=</span> <span class="s2">&quot;`which` must specify at least one of (L)eft or (R)ight&quot;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="s2">&quot;L&quot;</span> <span class="ow">in</span> <span class="n">which</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s2">&quot;R&quot;</span> <span class="ow">in</span> <span class="n">which</span><span class="p">),</span> <span class="n">err</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">diag_and_separate</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">needed</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Returns spectrum of c separated into entangled, filled, empty</span>
<span class="sd">            blocks.</span>

<span class="sd">            Modes are sorted by decreasing eigenvalue.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">needed</span><span class="p">:</span>  <span class="c1"># just need dummies for tuple unpacking</span>
                <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="mi">4</span>

            <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">assert</span> <span class="n">n</span> <span class="o">==</span> <span class="n">m</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Got non-square </span><span class="si">{</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> submatrix&quot;</span>

            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="nb">float</span><span class="p">)</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;filled&quot;</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                    <span class="s2">&quot;entangled&quot;</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                    <span class="s2">&quot;empty&quot;</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="n">e</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="mi">0</span>

            <span class="c1"># diagonalise c</span>
            <span class="n">e</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">eigh</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

            <span class="c1"># split empty and filled modes, determine number of each</span>
            <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">[</span><span class="n">cutoff</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">cutoff</span><span class="p">])</span>
            <span class="n">n0</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span> <span class="o">-</span> <span class="n">x0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">x1</span>

            <span class="c1"># order as desired</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;L&quot;</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;filled&quot;</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n1</span><span class="p">),</span>
                    <span class="s2">&quot;entangled&quot;</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">k</span><span class="p">),</span>
                    <span class="s2">&quot;empty&quot;</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="n">n1</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span>
                <span class="p">}</span>
            <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span><span class="p">:</span>
                <span class="n">idx</span><span class="p">[</span><span class="n">x0</span><span class="p">:</span><span class="n">x1</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">x0</span><span class="p">:</span><span class="n">x1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;empty&quot;</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x0</span><span class="p">),</span>
                    <span class="s2">&quot;entangled&quot;</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">),</span>
                    <span class="s2">&quot;filled&quot;</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span>
                <span class="p">}</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span>

            <span class="c1"># only keep Schmidt values for entangled modes</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="n">ix</span><span class="p">[</span><span class="s2">&quot;entangled&quot;</span><span class="p">]]</span>

            <span class="k">return</span> <span class="n">e</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">k</span>

        <span class="n">which</span> <span class="o">=</span> <span class="n">which</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>

        <span class="n">eL</span><span class="p">,</span> <span class="n">vL</span><span class="p">,</span> <span class="n">ixL</span><span class="p">,</span> <span class="n">kL</span> <span class="o">=</span> <span class="n">diag_and_separate</span><span class="p">(</span><span class="n">C</span><span class="p">[:</span><span class="n">x</span><span class="p">,</span> <span class="p">:</span><span class="n">x</span><span class="p">],</span> <span class="s2">&quot;L&quot;</span><span class="p">,</span> <span class="s2">&quot;L&quot;</span> <span class="ow">in</span> <span class="n">which</span><span class="p">)</span>
        <span class="n">eR</span><span class="p">,</span> <span class="n">vR</span><span class="p">,</span> <span class="n">ixR</span><span class="p">,</span> <span class="n">kR</span> <span class="o">=</span> <span class="n">diag_and_separate</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="n">x</span><span class="p">:,</span> <span class="n">x</span><span class="p">:],</span> <span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="s2">&quot;R&quot;</span> <span class="ow">in</span> <span class="n">which</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">eL</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">eR</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>  <span class="c1"># should error earlier</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">e</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">eR</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">kR</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">eR</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">eL</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">kL</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># both &quot;L&quot; and &quot;R&quot; were done, need consistency checks</span>
                <span class="k">assert</span> <span class="n">kL</span> <span class="o">==</span> <span class="n">kR</span>  <span class="c1"># number of entangled modes must match</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">kL</span>

                <span class="c1"># Shorthands</span>
                <span class="n">vLE</span> <span class="o">=</span> <span class="n">vL</span><span class="p">[:,</span> <span class="n">ixL</span><span class="p">[</span><span class="s2">&quot;entangled&quot;</span><span class="p">]]</span>
                <span class="n">vRE</span> <span class="o">=</span> <span class="n">vR</span><span class="p">[:,</span> <span class="n">ixR</span><span class="p">[</span><span class="s2">&quot;entangled&quot;</span><span class="p">]]</span>
                <span class="n">deg_tol</span> <span class="o">=</span> <span class="n">trunc_par</span><span class="o">.</span><span class="n">degeneracy_tol</span>

                <span class="c1"># Check that entangled mode weights sum to 1</span>
                <span class="n">err</span> <span class="o">=</span> <span class="s2">&quot;Eigenvalues of C_LL and C_RR do not match&quot;</span>
                <span class="n">assert_allclose</span><span class="p">(</span><span class="n">eL</span> <span class="o">+</span> <span class="n">eR</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">deg_tol</span><span class="p">,</span> <span class="n">err_msg</span><span class="o">=</span><span class="n">err</span><span class="p">)</span>

                <span class="n">e</span> <span class="o">=</span> <span class="n">eL</span>
                <span class="n">block_svd</span><span class="p">(</span><span class="n">C</span><span class="p">[:</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">:],</span> <span class="n">vLE</span><span class="p">,</span> <span class="n">vRE</span><span class="p">[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">e</span><span class="p">,</span> <span class="n">deg_tol</span><span class="p">)</span>

                <span class="c1"># add extra anticommutation signs</span>
                <span class="n">vRE</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> Schmidt modes found&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

        <span class="n">n_fermion</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">C</span><span class="p">)</span><span class="o">.</span><span class="n">real</span><span class="p">))</span>
        <span class="n">nR</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span>
        <span class="n">modes</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">n_fermion</span><span class="o">=</span><span class="n">n_fermion</span><span class="p">,</span> <span class="n">e</span><span class="o">=</span><span class="n">e</span><span class="p">,</span> <span class="n">vL</span><span class="o">=</span><span class="n">vL</span><span class="p">,</span> <span class="n">vR</span><span class="o">=</span><span class="n">vR</span><span class="p">,</span> <span class="n">ixL</span><span class="o">=</span><span class="n">ixL</span><span class="p">,</span> <span class="n">ixR</span><span class="o">=</span><span class="n">ixR</span><span class="p">,</span> <span class="n">nL</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">nR</span><span class="o">=</span><span class="n">nR</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">eL</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">eR</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">check_schmidt_decomposition</span><span class="p">(</span><span class="n">modes</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">diag_tol</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">modes</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">e_ratio</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;:math:`\log((1-\lambda)/\lambda` for all eigenvalues in :attr:`e`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">e</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">e</span><span class="p">)</span>

<div class="viewcode-block" id="SchmidtModes.embed_subsets">
<a class="viewcode-back" href="../../reference/slater.html#temfpy.slater.SchmidtModes.embed_subsets">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">embed_subsets</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sets</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Given an array of subsets of entangled orbitals occupied on the left</span>
<span class="sd">        side, generates the full sets of occupied orbitals on either side.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sets: bool :class:`~np.ndarray` (n, :attr:`n_entangled`)</span>
<span class="sd">            Array of occupation numbers.</span>

<span class="sd">            Each row specifies one Schmidt state by listing on which side of the</span>
<span class="sd">            entanglement cut each entangled orbital is filled:</span>
<span class="sd">            True if on the left side, False if on the right side.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        left_sets: bool :class:`~np.ndarray` (n, :attr:`size`\[0]) | :obj:`None`</span>
<span class="sd">            Occupation of every left orbital in the input Schmidt states.</span>

<span class="sd">            Returned if :attr:`vL` is not :obj:`None`.</span>
<span class="sd">        right_sets: bool :class:`~np.ndarray` (n, :attr:`size`\[1]) | :obj:`None`</span>
<span class="sd">            Occupation of every right orbital in the input Schmidt states.</span>

<span class="sd">            Returned if :attr:`vR` is not :obj:`None`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vL</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">left_sets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sets</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nL</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">left_sets</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ixL</span><span class="p">[</span><span class="s2">&quot;entangled&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">sets</span>
            <span class="n">left_sets</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ixL</span><span class="p">[</span><span class="s2">&quot;filled&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">left_sets</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vR</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">right_sets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sets</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nR</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">right_sets</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ixR</span><span class="p">[</span><span class="s2">&quot;entangled&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">sets</span><span class="p">[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">right_sets</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ixR</span><span class="p">[</span><span class="s2">&quot;filled&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">right_sets</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">left_sets</span><span class="p">,</span> <span class="n">right_sets</span></div>


<div class="viewcode-block" id="SchmidtModes.schmidt_values">
<a class="viewcode-back" href="../../reference/slater.html#temfpy.slater.SchmidtModes.schmidt_values">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">schmidt_values</span><span class="p">(</span><span class="n">modes</span><span class="p">,</span> <span class="n">sets</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Schmidt values of the Schmidt vectors with given occupation numbers.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sets: bool :class:`~np.ndarray` (n, :attr:`n_entangled`)</span>
<span class="sd">            Array of occupation numbers.</span>

<span class="sd">            Each row specifies one Schmidt state by listing on which side of the</span>
<span class="sd">            entanglement cut each entangled orbital is filled:</span>
<span class="sd">            True if on the left side, False if on the right side.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Î»: :class:`np.ndarray` (n,)</span>
<span class="sd">            Schmidt values corresponding to the input Schmidt states.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sets</span><span class="p">,</span> <span class="n">modes</span><span class="o">.</span><span class="n">e</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">modes</span><span class="o">.</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span></div>
</div>



<span class="c1">#### SCHMIDT Vectors ####</span>
<span class="c1">#### ---------------- ####</span>
<div class="viewcode-block" id="SchmidtVectors">
<a class="viewcode-back" href="../../reference/slater.html#temfpy.slater.SchmidtVectors">[docs]</a>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SchmidtVectors</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Schmidt vectors of a Slater determinant.</span>

<span class="sd">    The Schmidt decomposition of the state :math:`|\psi\rangle` is given by</span>

<span class="sd">    .. math::</span>

<span class="sd">        |\psi\rangle &amp;= \sum_\alpha \lambda_\alpha |L_\alpha\rangle \otimes_g</span>
<span class="sd">                                                   |R_\alpha\rangle</span>

<span class="sd">        |L_\alpha\rangle &amp;= \prod_a (d^\dagger_{L,a})^{n^L_{\alpha a}} |0\rangle</span>

<span class="sd">        |R_\alpha\rangle &amp;= \prod_a (d^\dagger_{R,a})^{n^R_{\alpha a}} |0\rangle,</span>

<span class="sd">    where :math:`\lambda_\alpha` are the Schmidt values,</span>
<span class="sd">    :math:`d^\dagger_{L,a}` and :math:`d^\dagger_{L,a}` are the creation operators</span>
<span class="sd">    of the left and right Schmidt mode orbitals, and</span>
<span class="sd">    :math:`n^L_{\alpha a}` and :math:`n^R_{\alpha a}` are the occupation numbers</span>
<span class="sd">    of these orbitals in the Schmidt vectors.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">modes</span><span class="p">:</span> <span class="n">SchmidtModes</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The mean-field orbitals underlying the Schmidt vectors.&quot;&quot;&quot;</span>
    <span class="n">left_sets</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;bool (:attr:`n_schmidt`, :attr:`nL`) --</span>
<span class="sd">    Left Schmidt vectors.</span>
<span class="sd">     </span>
<span class="sd">    Each row contains the occupation :math:`n^L_{\alpha a}` of all left </span>
<span class="sd">    Schmidt modes in one left Schmidt vector :math:`|L_\alpha\rangle`,</span>
<span class="sd">    if :attr:`vL` is not :obj:`None`.&quot;&quot;&quot;</span>
    <span class="n">right_sets</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;bool (:attr:`n_schmidt`, :attr:`nR`) --</span>
<span class="sd">    Right Schmidt vectors.</span>
<span class="sd">      </span>
<span class="sd">    Each row contains the occupation :math:`n^R_{\alpha a}` of all left </span>
<span class="sd">    Schmidt modes in one left Schmidt vector :math:`|R_\alpha\rangle`,</span>
<span class="sd">    if :attr:`vR` is not :obj:`None`.&quot;&quot;&quot;</span>
    <span class="n">schmidt_values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;(:attr:`n_schmidt`,) --</span>
<span class="sd">    Schmidt values :math:`\lambda_\alpha` corresponding to each Schmidt vector.</span>
<span class="sd">     </span>
<span class="sd">    Sorted in increasing order of charge of the left Schmidt vector and</span>
<span class="sd">    in decreasing order within each charge sector.&quot;&quot;&quot;</span>
    <span class="n">idx_L</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">slice</span><span class="p">]</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Maps the total charge to the left of the entanglement cut to the</span>
<span class="sd">    slice of sets/singular values with that charge.</span>

<span class="sd">    That is, all Schmidt vectors in ``left_sets[idx_L[n]]`` contain n particles.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">n_schmidt</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The number of Schmidt vectors.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">schmidt_values</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">n_entangled</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of entangled orbitals.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="o">.</span><span class="n">n_entangled</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nL</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Size of the left half of the system.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="o">.</span><span class="n">nL</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nR</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Size of the right half of the system.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="o">.</span><span class="n">nR</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">n_fermion</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of fermions in the mean-field state.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="o">.</span><span class="n">n_fermion</span>

<div class="viewcode-block" id="SchmidtVectors.size">
<a class="viewcode-back" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.size">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;T&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Size of the specified half or the whole of the system.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        which:</span>
<span class="sd">            Either &quot;L&quot; for left or &quot;R&quot; for right side</span>
<span class="sd">            or &quot;T&quot; (default) for total size.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            the appropriate system size.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">which</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">vL</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Left Schmidt mode orbitals :attr:`~SchmidtModes.vL`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="o">.</span><span class="n">vL</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">vR</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Right Schmidt mode orbitals :attr:`~SchmidtModes.vR`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="o">.</span><span class="n">vR</span>

<div class="viewcode-block" id="SchmidtVectors.mode_vectors">
<a class="viewcode-back" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.mode_vectors">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mode_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">entangled</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the Schmidt mode orbitals on the specified side.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        which:</span>
<span class="sd">            Either &quot;L&quot; for left or &quot;R&quot; for right side.</span>
<span class="sd">        entangled:</span>
<span class="sd">            Whether to return the entangled (:obj:`True`) or</span>
<span class="sd">            all (:obj:`False`, default) eigenvectors.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            Either :attr:`vL` or :attr:`vR`, depending on ``which``,</span>
<span class="sd">            truncated to entangled modes if ``entangled``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="o">.</span><span class="n">mode_vectors</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="n">entangled</span><span class="p">)</span></div>


<div class="viewcode-block" id="SchmidtVectors.sets">
<a class="viewcode-back" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.sets">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the sets of occupied orbitals on the specified side.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        which:</span>
<span class="sd">            Either &quot;L&quot; for left or &quot;R&quot; for right side.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            Either :attr:`left_sets` or :attr:`right_sets`, depending on ``which``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">which_</span> <span class="o">=</span> <span class="n">which</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">which_</span> <span class="o">==</span> <span class="s2">&quot;L&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">left_sets</span>
        <span class="k">elif</span> <span class="n">which_</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">right_sets</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`which` must start with L or R, got &quot;</span> <span class="o">+</span> <span class="n">which</span><span class="p">)</span></div>


<div class="viewcode-block" id="SchmidtVectors.from_schmidt_modes">
<a class="viewcode-back" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.from_schmidt_modes">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_schmidt_modes</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="s2">&quot;SchmidtVectors&quot;</span><span class="p">],</span>
        <span class="n">modes</span><span class="p">:</span> <span class="n">SchmidtModes</span><span class="p">,</span>
        <span class="n">trunc_par</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="n">StoppingCondition</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;SchmidtVectors&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The most significant :class:`SchmidtVectors` from the given</span>
<span class="sd">        :class:`SchmidtModes`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        modes:</span>
<span class="sd">            The Schmidt modes.</span>
<span class="sd">        trunc_par:</span>
<span class="sd">            Specifies which Schmidt states should be kept.</span>

<span class="sd">            Must be either a :class:`~temfpy.schmidt_utils.StoppingCondition` object</span>
<span class="sd">            or a dictionary with matching keys.</span>

<span class="sd">            If ``modes`` contains left modes,</span>
<span class="sd">            the filtering function :attr:`~StoppingCondition.sectors`</span>
<span class="sd">            is applied to the total number of particles to the left,</span>
<span class="sd">            otherwise, to the total number of particles to the right.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trunc_par</span> <span class="o">=</span> <span class="n">to_stopping_condition</span><span class="p">(</span><span class="n">trunc_par</span><span class="p">)</span>

        <span class="c1"># find the sets of mixed left states with the largest Schmidt</span>
        <span class="c1"># value, bzw. the largest product of the corresponding L (R for the rest)</span>
        <span class="c1"># this is equivalent to finding the subsets with the lowest sum of log(R/L)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">sets</span> <span class="o">=</span> <span class="n">lowest_sums</span><span class="p">(</span>
            <span class="n">modes</span><span class="o">.</span><span class="n">e_ratio</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>  <span class="c1"># apply svd_min to the Schmidt values not squared</span>
            <span class="n">trunc_par</span><span class="p">,</span>
            <span class="n">filled_left</span><span class="o">=</span><span class="n">modes</span><span class="o">.</span><span class="n">n_filled</span><span class="p">(</span><span class="s2">&quot;L&quot;</span><span class="p">),</span>
            <span class="n">filled_right</span><span class="o">=</span><span class="n">modes</span><span class="o">.</span><span class="n">n_filled</span><span class="p">(</span><span class="s2">&quot;R&quot;</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">err</span> <span class="o">=</span> <span class="s2">&quot;No Schmidt vectors left after filtering by `trunc_par.sectors`!&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>

        <span class="c1"># compute particle number in Schmidt vectors for sorting</span>
        <span class="n">n_L</span> <span class="o">=</span> <span class="n">modes</span><span class="o">.</span><span class="n">n_filled</span><span class="p">(</span><span class="s2">&quot;L&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">sets</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># sort by n_L</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">n_L</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;stable&quot;</span><span class="p">)</span>
        <span class="n">n_L</span> <span class="o">=</span> <span class="n">n_L</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">sets</span> <span class="o">=</span> <span class="n">sets</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="c1"># cluster by n_L</span>
        <span class="n">n_L</span><span class="p">,</span> <span class="n">idx_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">n_L</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">idx_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">idx_L</span><span class="p">,</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">sets</span><span class="p">)]))</span>
        <span class="n">idx_L</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="n">idx_L</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">idx_L</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">n_L</span><span class="p">)}</span>

        <span class="c1"># embed `sets` into the full span of Schmidt modes</span>
        <span class="n">left_sets</span><span class="p">,</span> <span class="n">right_sets</span> <span class="o">=</span> <span class="n">modes</span><span class="o">.</span><span class="n">embed_subsets</span><span class="p">(</span><span class="n">sets</span><span class="p">)</span>

        <span class="c1"># compute Schmidt values</span>
        <span class="n">Î»</span> <span class="o">=</span> <span class="n">modes</span><span class="o">.</span><span class="n">schmidt_values</span><span class="p">(</span><span class="n">sets</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> Schmidt vectors generated&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">Î»</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Dynamical range: </span><span class="si">%.3e</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">Î»</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">/</span> <span class="n">Î»</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">modes</span><span class="o">=</span><span class="n">modes</span><span class="p">,</span>
            <span class="n">left_sets</span><span class="o">=</span><span class="n">left_sets</span><span class="p">,</span>
            <span class="n">right_sets</span><span class="o">=</span><span class="n">right_sets</span><span class="p">,</span>
            <span class="n">schmidt_values</span><span class="o">=</span><span class="n">Î»</span><span class="p">,</span>
            <span class="n">idx_L</span><span class="o">=</span><span class="n">idx_L</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="SchmidtVectors.from_correlation_matrix">
<a class="viewcode-back" href="../../reference/slater.html#temfpy.slater.SchmidtVectors.from_correlation_matrix">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_correlation_matrix</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="s2">&quot;SchmidtVectors&quot;</span><span class="p">],</span>
        <span class="n">C</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">trunc_par</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="n">StoppingCondition</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">which</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;LR&quot;</span><span class="p">,</span>
        <span class="n">diag_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_DIAG_TOL</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;SchmidtVectors&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Most significant :class:`~SchmidtVectors` of a Slater determinant with</span>
<span class="sd">        correlation matrix ``C`` for an entanglement cut between sites</span>
<span class="sd">        ``x-1`` and ``x`` (zero-indexed).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        C:</span>
<span class="sd">            The correlation matrix, :math:`C_{ij} = \langle c_j^\dagger c_i\rangle`.</span>
<span class="sd">        x:</span>
<span class="sd">            Position of the entanglement cut.</span>
<span class="sd">        trunc_par:</span>
<span class="sd">            Specifies which Schmidt states should be kept.</span>

<span class="sd">            Must be either a :class:`~temfpy.schmidt_utils.StoppingCondition` object</span>
<span class="sd">            or a dictionary with matching keys.</span>

<span class="sd">            If left Schmidt modes are calculated,</span>
<span class="sd">            the filtering function :attr:`~StoppingCondition.sectors`</span>
<span class="sd">            is applied to the total number of particles to the left,</span>
<span class="sd">            otherwise, to the total number of particles to the right.</span>
<span class="sd">        which:</span>
<span class="sd">            Whether to return left and/or right Schmidt modes.</span>

<span class="sd">            Must be a combination of ``&quot;L&quot;`` and ``&quot;R&quot;``.</span>
<span class="sd">        diag_tol:</span>
<span class="sd">            If ``which == &quot;LR&quot;``, largest allowed offdiagonal matrix element in</span>
<span class="sd">            diagonalised / SVD correlation submatrices before an error is</span>
<span class="sd">            raised.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        - If :attr:`trunc_par.svd_min` is not provided, the truncation threshold</span>
<span class="sd">          defaults to 1e-6.</span>
<span class="sd">        - If :attr:`trunc_par.degeneracy_tol` is not provided, the degeneracy tolerance</span>
<span class="sd">          defaults to 1e-12.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">which</span> <span class="o">=</span> <span class="n">which</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="n">trunc_par</span> <span class="o">=</span> <span class="n">to_stopping_condition</span><span class="p">(</span><span class="n">trunc_par</span><span class="p">)</span>

        <span class="n">modes</span> <span class="o">=</span> <span class="n">SchmidtModes</span><span class="o">.</span><span class="n">from_correlation_matrix</span><span class="p">(</span>
            <span class="n">C</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">trunc_par</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="n">which</span><span class="p">,</span> <span class="n">diag_tol</span><span class="o">=</span><span class="n">diag_tol</span>
        <span class="p">)</span>
        <span class="n">vectors</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_schmidt_modes</span><span class="p">(</span><span class="n">modes</span><span class="p">,</span> <span class="n">trunc_par</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vectors</span></div>
</div>



<span class="c1">#### MPSTensorData from SCHMIDT Vectors ####</span>
<span class="c1">#### ---------------------------------- ####</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_select_orbitals</span><span class="p">(</span>
    <span class="n">sets</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Crops Schmidt orbitals to always + sometimes orbitals</span>
<span class="sd">    and computed anticommutation signs due to reordering.</span>

<span class="sd">    If MPS tensors are to be computed, the on-site degree of freedom</span>
<span class="sd">    must be explicitly added to ``sets`` and ``V`` as one of the</span>
<span class="sd">    &quot;sometimes&quot; orbitals.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sets:</span>
<span class="sd">        :attr:`SchmidtVectors.left_sets` or :attr:`SchmidtVectors.right_sets`,</span>
<span class="sd">        depending on ``mode``.</span>
<span class="sd">    V:</span>
<span class="sd">        :attr:`SchmidtModes.vL` or :attr:`SchmidtModes.vR`, depending on ``mode``.</span>
<span class="sd">    mode:</span>
<span class="sd">        whether ``sets`` corresponds to a &quot;left&quot; or &quot;right&quot; set</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sets:</span>
<span class="sd">        Input `sets` trimmed to always + sometimes orbitals.</span>
<span class="sd">    V:</span>
<span class="sd">        Input `V` trimmed to always + sometimes orbitals.</span>

<span class="sd">        Includes commutation sign to move sometimes orbitals to the &quot;right&quot;</span>
<span class="sd">        or to the &quot;left&quot; of the occupied orbitals, depending on ``mode``.</span>
<span class="sd">    k:</span>
<span class="sd">        Number of always orbitals.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">always</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">sets</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">never</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">sets</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
    <span class="n">sometimes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">always</span> <span class="o">|</span> <span class="n">never</span><span class="p">)</span>

    <span class="p">(</span><span class="n">always</span><span class="p">,)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">always</span><span class="p">)</span>
    <span class="p">(</span><span class="n">sometimes</span><span class="p">,)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">sometimes</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">always</span><span class="p">)</span>

    <span class="c1"># There may be some entangled orbitals that are always occupied,</span>
    <span class="c1"># due to the additional cutoff of Schmidt vectors by `chi_max`. We now move</span>
    <span class="c1"># these orbitals to one side of the occupied block resulting in</span>
    <span class="c1"># commutation signs, keeping the relative order of the sometimes</span>
    <span class="c1"># orbitals. The commutation sign is calculated for the sometimes orbitals</span>
    <span class="c1"># because the always orbitals are the same for all Schmidt vectors.</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">always</span><span class="p">,</span> <span class="n">sometimes</span><span class="p">))</span>
        <span class="c1"># For the left Schmidt vectors, we want to move the sometimes orbitals</span>
        <span class="c1"># to the right. The number of commutations for each sometimes orbital</span>
        <span class="c1"># is therefore the number of always orbitals to its right,</span>
        <span class="c1"># which is the total number of always orbitals minus the number of</span>
        <span class="c1"># always orbitals to its left.</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">always</span><span class="p">,</span> <span class="n">sometimes</span><span class="p">))</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">sign</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">sometimes</span><span class="p">,</span> <span class="n">always</span><span class="p">))</span>
        <span class="c1"># For the right Schmidt vectors, we want to move the entangled orbitals</span>
        <span class="c1"># to the left. The number of commutations for each sometimes orbital is</span>
        <span class="c1"># therefore the number of always orbitals to its left.</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">always</span><span class="p">,</span> <span class="n">sometimes</span><span class="p">)</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">sign</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">k</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;mode needs to be either &quot;left&quot; or &quot;right&quot;&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sets</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">],</span> <span class="n">V</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">sign</span><span class="p">,</span> <span class="n">k</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_tensor_block</span><span class="p">(</span>
    <span class="n">sometimes_matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">new_sets_bra</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">new_sets_ket</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes a fixed-particle-number block of the MPS tensor.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    new_sets_bra:</span>
<span class="sd">        rows of :attr:`new_sets_bra` corresponding to a given charge</span>
<span class="sd">        physical leg must be set appropriately too</span>
<span class="sd">    new_sets_ket:</span>
<span class="sd">        rows of :attr:`new_sets_ket` corresponding to a given charge</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    The MPS tensor block for the given charges.</span>
<span class="sd">    The row index always corresponds to the `bra` leg</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># check that every new_set has the same number of particles</span>
    <span class="n">n_bra</span> <span class="o">=</span> <span class="n">new_sets_bra</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">n_bra</span> <span class="o">==</span> <span class="n">n_bra</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">n_bra</span> <span class="o">=</span> <span class="n">n_bra</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">n_ket</span> <span class="o">=</span> <span class="n">new_sets_ket</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">n_ket</span> <span class="o">==</span> <span class="n">n_ket</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">n_ket</span> <span class="o">=</span> <span class="n">n_ket</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">assert</span> <span class="n">n_bra</span> <span class="o">==</span> <span class="n">n_ket</span>

    <span class="c1"># convert new_sets to lists of positions for convenience</span>
    <span class="n">nsb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_sets_bra</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">new_sets_bra</span> <span class="o">=</span> <span class="n">new_sets_bra</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
    <span class="n">new_sets_bra</span> <span class="o">=</span> <span class="n">new_sets_bra</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nsb</span><span class="p">,</span> <span class="n">n_bra</span><span class="p">)</span>

    <span class="n">nsk</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_sets_ket</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">new_sets_ket</span> <span class="o">=</span> <span class="n">new_sets_ket</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
    <span class="n">new_sets_ket</span> <span class="o">=</span> <span class="n">new_sets_ket</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nsk</span><span class="p">,</span> <span class="n">n_ket</span><span class="p">)</span>

    <span class="n">O</span> <span class="o">=</span> <span class="n">sometimes_matrix</span><span class="p">[</span><span class="n">new_sets_bra</span><span class="p">][:,</span> <span class="p">:,</span> <span class="n">new_sets_ket</span><span class="p">]</span>
    <span class="n">O</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">O</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">det</span><span class="p">(</span><span class="n">O</span><span class="p">)</span>


<div class="viewcode-block" id="MPSTensorData">
<a class="viewcode-back" href="../../reference/slater.html#temfpy.slater.MPSTensorData">[docs]</a>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MPSTensorData</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Data for computing one MPS tensor of a Slater determinant.</span>

<span class="sd">    - If :attr:`mode` is ``&quot;left&quot;``, contains an implicit description of the</span>
<span class="sd">      left canonical tensor</span>

<span class="sd">      .. math::</span>

<span class="sd">        A^{n_i}_{\alpha\beta} =</span>
<span class="sd">        (\langle n_i | \otimes_g \langle L^{(i-1)}_\alpha|)</span>
<span class="sd">        | L^{(i)}_\beta \rangle.</span>

<span class="sd">    - If :attr:`mode` is ``&quot;right&quot;``, contains an implicit description of the</span>
<span class="sd">      right canonical tensor</span>

<span class="sd">      .. math::</span>

<span class="sd">        B^{n_i}_{\beta\alpha} =</span>
<span class="sd">        (\langle R^{(i)}_\alpha | \otimes_g \langle n_i |)</span>
<span class="sd">        | R^{(i-1)}_\beta \rangle.</span>

<span class="sd">    Schmidt vector overlaps for equal-length chains can also be computed:</span>

<span class="sd">    .. math::</span>

<span class="sd">        A_{\alpha\beta} &amp;= \langle L&#39;_\alpha | L_\beta \rangle</span>

<span class="sd">        B_{\beta\alpha} &amp;= \langle R&#39;_\beta | R_\alpha \rangle</span>

<span class="sd">    For Slater determinants, such overlaps are the determinants of the</span>
<span class="sd">    overlaps of the single-particle orbital wave functions. Many of these</span>
<span class="sd">    orbitals are shared between every Schmidt vector, so we can compute</span>
<span class="sd">    the determinants efficiently using the identity</span>

<span class="sd">    .. math::</span>

<span class="sd">        \det \begin{bmatrix}A &amp; B \\ C &amp; D\end{bmatrix} =</span>
<span class="sd">        \det(A) \det\left(D - C A^{-1} B\right) =</span>
<span class="sd">        \det(D) \det\left(A - B D^{-1} C\right).</span>

<span class="sd">    Namely, if the block :math:`A` or block :math:`D` contains the overlaps</span>
<span class="sd">    of the always occupied orbitals, its determinant is only computed once.</span>
<span class="sd">    Furthermore, each determinant entry :math:`\left(D - C A^{-1} B\right)_{ij}` /</span>
<span class="sd">    :math:`\left(A - B D^{-1} C\right)_{ij}` depends only on &quot;bra&quot; orbital `i`</span>
<span class="sd">    and &quot;ket&quot; orbital `j`, so they can be precomputed for all pairs of</span>
<span class="sd">    sometimes-occupied orbitals.</span>

<span class="sd">    - For left Schmidt vectors, the always occupied orbitals are listed before</span>
<span class="sd">      the entangled ones (cf. :attr:`SchmidtModes.vL`).</span>
<span class="sd">      Therefore, we use the first form of the identity if ``mode == &quot;left&quot;``.</span>
<span class="sd">    - For right Schmidt vectors, the always occupied orbitals are listed after</span>
<span class="sd">      the entangled ones (cf. :attr:`SchmidtModes.vR`).</span>
<span class="sd">      Therefore, we use the second form of the identity if ``mode == &quot;right&quot;``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Whether the overlap is between ``&quot;left&quot;`` or ``&quot;right&quot;`` Schmidt vectors.&quot;&quot;&quot;</span>
    <span class="n">physical_leg</span><span class="p">:</span> <span class="nb">bool</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Whether an MPS tensor with a physical leg (:obj:`True`) or an array of</span>
<span class="sd">    overlaps (:obj:`False`) is to be computed.&quot;&quot;&quot;</span>
    <span class="n">det_always</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">complex</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Overlap determinant of the always occupied orbitals,</span>
<span class="sd">    :math:`\det(A)` or :math:`\det(D)`.&quot;&quot;&quot;</span>
    <span class="n">sometimes_matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Entries of the matrix :math:`\left(D - C A^{-1} B\right)` or</span>
<span class="sd">    :math:`\left(A - B D^{-1} C\right)` for all pairs of sometimes-occupied orbitals.&quot;&quot;&quot;</span>
    <span class="n">idx_bra</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">slice</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;:attr:`~SchmidtVectors.idx_L` of the bra Schmidt vector.&quot;&quot;&quot;</span>
    <span class="n">idx_ket</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">slice</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;:attr:`~SchmidtVectors.idx_L` of the ket Schmidt vector.&quot;&quot;&quot;</span>
    <span class="n">new_sets_bra</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Bra Schmidt vectors as occupation numbers of the sometimes-occupied orbitals.</span>
<span class="sd">    </span>
<span class="sd">    Used to index the rows of :attr:`sometimes_matrix`.</span>
<span class="sd">    </span>
<span class="sd">    If :attr:`physical` is :obj:`True`, it is double the length of</span>
<span class="sd">    :attr:`~SchmidtVectors.sets` and contains all Schmidt vectors with the on-site</span>
<span class="sd">    degree of freedom once empty, one filled. The overall array is still sorted</span>
<span class="sd">    by total charge to the left; within each sector, we first take the &quot;Schmidt</span>
<span class="sd">    vectors&quot; with empty on-site orbital.&quot;&quot;&quot;</span>
    <span class="n">new_sets_ket</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Ket Schmidt vectors as occupation numbers of the sometimes-occupied orbitals.</span>
<span class="sd">    </span>
<span class="sd">    Used to index the columns of :attr:`sometimes_matrix`.&quot;&quot;&quot;</span>
    <span class="n">qtotal</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Total charge of the tensor to ensure matching fermion numbers in</span>
<span class="sd">    Schmidt vectors.</span>
<span class="sd">    </span>
<span class="sd">    - For ``mode == &quot;left&quot;``, always 0.</span>
<span class="sd">    - For ``mode == &quot;right&quot;``, equals the difference of :attr:`~SchmidtVectors.n_fermion`</span>
<span class="sd">      between the ket and bra Schmidt vectors.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">idx_physical</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Row index of the onsite degree of freedom in :attr:`sometimes_matrix`</span>
<span class="sd">        or :obj:`None` if there is no such degree of freedom.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">physical_leg</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sometimes_matrix</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="MPSTensorData.from_schmidt_vectors">
<a class="viewcode-back" href="../../reference/slater.html#temfpy.slater.MPSTensorData.from_schmidt_vectors">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_schmidt_vectors</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="s2">&quot;MPSTensorData&quot;</span><span class="p">],</span>
        <span class="n">Schmidt_bra</span><span class="p">:</span> <span class="n">SchmidtVectors</span><span class="p">,</span>
        <span class="n">Schmidt_ket</span><span class="p">:</span> <span class="n">SchmidtVectors</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;MPSTensorData&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs :class:`MPSTensorData` from Schmidt vectors on the two</span>
<span class="sd">        entanglement cuts next to a site.</span>

<span class="sd">        Depending on the value of ``mode``, it uses either &quot;left&quot; or &quot;right&quot;</span>
<span class="sd">        Schmidt vectors, resulting in a left or right canonical MPS tensor,</span>
<span class="sd">        respectively.</span>
<span class="sd">        In both cases, ``Schmidt_bra`` corresponds to Schmidt vectors on the</span>
<span class="sd">        shorter chain.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Schmidt_bra:</span>
<span class="sd">            Schmidt vectors corresponding to the bra states in the overlap.</span>

<span class="sd">            That is, for the entanglement cut to the left if ``mode==&quot;left&quot;``</span>
<span class="sd">            or to the right if ``mode=&quot;right&quot;``.</span>
<span class="sd">        Schmidt_ket:</span>
<span class="sd">            Schmidt vectors corresponding to the ket states in the overlap.</span>

<span class="sd">            That is, for the entanglement cut to the right if ``mode==&quot;left&quot;``</span>
<span class="sd">            or to the left if ``mode=&quot;right&quot;``.</span>
<span class="sd">        mode:</span>
<span class="sd">            Whether to construct the tensor from left or right Schmidt vectors.</span>

<span class="sd">            Must be either &quot;left&quot; or &quot;right&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;mode must be either &#39;left&#39; or &#39;right&#39;, got &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>

        <span class="c1"># shorthands</span>
        <span class="n">v_bra</span> <span class="o">=</span> <span class="n">Schmidt_bra</span><span class="o">.</span><span class="n">mode_vectors</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">v_bra</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;`Schmidt_bra` contains no </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2"> Schmidt vectors&quot;</span>
        <span class="n">sets_bra</span> <span class="o">=</span> <span class="n">Schmidt_bra</span><span class="o">.</span><span class="n">sets</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>

        <span class="n">v_ket</span> <span class="o">=</span> <span class="n">Schmidt_ket</span><span class="o">.</span><span class="n">mode_vectors</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">v_ket</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;`Schmidt_ket` contains no </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2"> Schmidt vectors&quot;</span>
        <span class="n">sets_ket</span> <span class="o">=</span> <span class="n">Schmidt_ket</span><span class="o">.</span><span class="n">sets</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>

        <span class="c1"># bra must be 1 longer than ket</span>
        <span class="k">if</span> <span class="n">sets_bra</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">sets_ket</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">physical</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">sets_bra</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">sets_ket</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">physical</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">ns_bra</span><span class="p">,</span> <span class="n">n_bra</span> <span class="o">=</span> <span class="n">sets_bra</span><span class="o">.</span><span class="n">shape</span>
            <span class="c1"># add the physical orbital and combine sets_bra and sets_phys</span>
            <span class="c1"># sets_phys shall be more major to sets_bra</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span>
                <span class="c1"># Add the physical orbital to the end</span>
                <span class="n">v_bra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">(</span>
                    <span class="p">[[</span><span class="n">v_bra</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_bra</span><span class="p">,</span> <span class="mi">1</span><span class="p">))],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_bra</span><span class="p">)),</span> <span class="mi">1</span><span class="p">]]</span>
                <span class="p">)</span>
                <span class="n">sets_bra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="p">[</span><span class="n">sets_bra</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ns_bra</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">bool</span><span class="p">)],</span>
                        <span class="p">[</span><span class="n">sets_bra</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">ns_bra</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">bool</span><span class="p">)],</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># mode == &quot;right&quot;:</span>
                <span class="c1"># Add the physical orbital to the front</span>
                <span class="n">v_bra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">(</span>
                    <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_bra</span><span class="p">))],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_bra</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">v_bra</span><span class="p">]]</span>
                <span class="p">)</span>
                <span class="n">sets_bra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ns_bra</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">bool</span><span class="p">),</span> <span class="n">sets_bra</span><span class="p">],</span>
                        <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">ns_bra</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">bool</span><span class="p">),</span> <span class="n">sets_bra</span><span class="p">],</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="c1"># sort by total charge to the left, keeping each sector in original order</span>
            <span class="n">q_bra_sets</span> <span class="o">=</span> <span class="n">sets_bra</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">ix_bra_sets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span>
                <span class="n">q_bra_sets</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span> <span class="k">else</span> <span class="o">-</span><span class="n">q_bra_sets</span><span class="p">,</span>  <span class="c1"># proxy for q_left</span>
                <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;stable&quot;</span><span class="p">,</span>  <span class="c1"># charge sectors have to remain in original order</span>
            <span class="p">)</span>
            <span class="n">sets_bra</span> <span class="o">=</span> <span class="n">sets_bra</span><span class="p">[</span><span class="n">ix_bra_sets</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">mode</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span><span class="si">}</span><span class="s2"> sides `Schmidt_bra` and `Schmidt_ket` must match</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;or `Schmidt_bra` must be one bond to the </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2"> of `Schmidt_ket`,</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;got lengths </span><span class="si">{</span><span class="n">sets_bra</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">sets_ket</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="n">sets_bra</span><span class="p">,</span> <span class="n">v_bra</span><span class="p">,</span> <span class="n">k_bra</span> <span class="o">=</span> <span class="n">_select_orbitals</span><span class="p">(</span><span class="n">sets_bra</span><span class="p">,</span> <span class="n">v_bra</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
        <span class="n">sets_ket</span><span class="p">,</span> <span class="n">v_ket</span><span class="p">,</span> <span class="n">k_ket</span> <span class="o">=</span> <span class="n">_select_orbitals</span><span class="p">(</span><span class="n">sets_ket</span><span class="p">,</span> <span class="n">v_ket</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>

        <span class="n">k</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">k_bra</span><span class="p">,</span> <span class="n">k_ket</span><span class="p">)</span>  <span class="c1"># need square &quot;always&quot; matrix</span>

        <span class="n">O</span> <span class="o">=</span> <span class="n">HT</span><span class="p">(</span><span class="n">v_bra</span><span class="p">)</span> <span class="o">@</span> <span class="n">v_ket</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># no &quot;always&quot; orbitals, default to standard method with &quot;sometimes&quot; orbitals</span>
            <span class="n">det_always</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="n">sometimes_matrix</span> <span class="o">=</span> <span class="n">O</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span>
            <span class="c1"># det(a,b;c,d) = det(a) det[d - c inv(a) b]</span>
            <span class="n">det_always</span> <span class="o">=</span> <span class="n">det</span><span class="p">(</span><span class="n">O</span><span class="p">[:</span><span class="n">k</span><span class="p">,</span> <span class="p">:</span><span class="n">k</span><span class="p">])</span>
            <span class="n">sometimes_matrix</span> <span class="o">=</span> <span class="n">O</span><span class="p">[</span><span class="n">k</span><span class="p">:,</span> <span class="n">k</span><span class="p">:]</span> <span class="o">-</span> <span class="n">O</span><span class="p">[</span><span class="n">k</span><span class="p">:,</span> <span class="p">:</span><span class="n">k</span><span class="p">]</span> <span class="o">@</span> <span class="n">inv</span><span class="p">(</span><span class="n">O</span><span class="p">[:</span><span class="n">k</span><span class="p">,</span> <span class="p">:</span><span class="n">k</span><span class="p">])</span> <span class="o">@</span> <span class="n">O</span><span class="p">[:</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">:]</span>
            <span class="n">sets_bra</span> <span class="o">=</span> <span class="n">sets_bra</span><span class="p">[:,</span> <span class="n">k</span><span class="p">:]</span>
            <span class="n">sets_ket</span> <span class="o">=</span> <span class="n">sets_ket</span><span class="p">[:,</span> <span class="n">k</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># mode == &quot;right&quot;:</span>
            <span class="c1"># det(a,b;c,d) = det(d) det[a - b inv(d) c]</span>
            <span class="n">det_always</span> <span class="o">=</span> <span class="n">det</span><span class="p">(</span><span class="n">O</span><span class="p">[</span><span class="o">-</span><span class="n">k</span><span class="p">:,</span> <span class="o">-</span><span class="n">k</span><span class="p">:])</span>
            <span class="n">sometimes_matrix</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">O</span><span class="p">[:</span><span class="o">-</span><span class="n">k</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">O</span><span class="p">[:</span><span class="o">-</span><span class="n">k</span><span class="p">,</span> <span class="o">-</span><span class="n">k</span><span class="p">:]</span> <span class="o">@</span> <span class="n">inv</span><span class="p">(</span><span class="n">O</span><span class="p">[</span><span class="o">-</span><span class="n">k</span><span class="p">:,</span> <span class="o">-</span><span class="n">k</span><span class="p">:])</span> <span class="o">@</span> <span class="n">O</span><span class="p">[</span><span class="o">-</span><span class="n">k</span><span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="n">k</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">sets_bra</span> <span class="o">=</span> <span class="n">sets_bra</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="n">k</span><span class="p">]</span>
            <span class="n">sets_ket</span> <span class="o">=</span> <span class="n">sets_ket</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="n">k</span><span class="p">]</span>

        <span class="n">qtotal</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span> <span class="k">else</span> <span class="n">Schmidt_ket</span><span class="o">.</span><span class="n">n_fermion</span> <span class="o">-</span> <span class="n">Schmidt_bra</span><span class="o">.</span><span class="n">n_fermion</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">physical_leg</span><span class="o">=</span><span class="n">physical</span><span class="p">,</span>
            <span class="n">det_always</span><span class="o">=</span><span class="n">det_always</span><span class="p">,</span>
            <span class="n">sometimes_matrix</span><span class="o">=</span><span class="n">sometimes_matrix</span><span class="p">,</span>
            <span class="n">idx_bra</span><span class="o">=</span><span class="n">Schmidt_bra</span><span class="o">.</span><span class="n">idx_L</span><span class="p">,</span>
            <span class="n">idx_ket</span><span class="o">=</span><span class="n">Schmidt_ket</span><span class="o">.</span><span class="n">idx_L</span><span class="p">,</span>
            <span class="n">new_sets_bra</span><span class="o">=</span><span class="n">sets_bra</span><span class="p">,</span>
            <span class="n">new_sets_ket</span><span class="o">=</span><span class="n">sets_ket</span><span class="p">,</span>
            <span class="n">qtotal</span><span class="o">=</span><span class="n">qtotal</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="MPSTensorData.to_npc_array">
<a class="viewcode-back" href="../../reference/slater.html#temfpy.slater.MPSTensorData.to_npc_array">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_npc_array</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npc</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The MPS tensor as a TeNPy :class:`~tenpy.linalg.np_conserved.Array` object.&quot;&quot;&quot;</span>

        <span class="c1"># Legs of the tensor</span>
        <span class="c1"># ------------------</span>
        <span class="n">qconj</span> <span class="o">=</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span> <span class="k">else</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">name_bra</span><span class="p">,</span> <span class="n">name_ket</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;vL&quot;</span><span class="p">,</span> <span class="s2">&quot;vR&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span> <span class="k">else</span> <span class="p">(</span><span class="s2">&quot;vR&quot;</span><span class="p">,</span> <span class="s2">&quot;vL&quot;</span><span class="p">)</span>
        <span class="n">leg_bra</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">LegCharge</span><span class="o">.</span><span class="n">from_qdict</span><span class="p">(</span><span class="n">chinfo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_bra</span><span class="p">,</span> <span class="n">qconj</span><span class="o">=</span><span class="n">qconj</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">leg_ket</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">LegCharge</span><span class="o">.</span><span class="n">from_qdict</span><span class="p">(</span><span class="n">chinfo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_ket</span><span class="p">,</span> <span class="n">qconj</span><span class="o">=</span><span class="n">qconj</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">physical_leg</span><span class="p">:</span>
            <span class="c1"># merge the physical leg into leg_bra</span>
            <span class="c1"># the physical leg must be more major to align with new_sets_bra</span>
            <span class="n">leg_bra</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">LegPipe</span><span class="p">([</span><span class="n">fermion_leg</span><span class="p">,</span> <span class="n">leg_bra</span><span class="p">],</span> <span class="n">qconj</span><span class="o">=</span><span class="n">leg_bra</span><span class="o">.</span><span class="n">qconj</span><span class="p">)</span>
            <span class="n">name_bra</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;(p.</span><span class="si">{</span><span class="n">name_bra</span><span class="si">}</span><span class="s2">)&quot;</span>

        <span class="c1"># create the tensor</span>
        <span class="c1"># ----------------</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">[</span><span class="n">leg_bra</span><span class="p">,</span> <span class="n">leg_ket</span><span class="p">],</span>
            <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="n">name_bra</span><span class="p">,</span> <span class="n">name_ket</span><span class="p">],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sometimes_matrix</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">qtotal</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qtotal</span><span class="p">,),</span>
        <span class="p">)</span>

        <span class="c1"># Fill all charge blocks of the tensor</span>
        <span class="c1"># ------------------------------------</span>
        <span class="n">qdict_bra</span> <span class="o">=</span> <span class="n">leg_bra</span><span class="o">.</span><span class="n">to_qdict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">q_ket</span><span class="p">,</span> <span class="n">slice_ket</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_ket</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">q_bra</span> <span class="o">=</span> <span class="n">q_ket</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">*</span> <span class="n">qconj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">q_bra</span><span class="p">,)</span> <span class="ow">in</span> <span class="n">qdict_bra</span><span class="p">:</span>
                <span class="n">slice_bra</span> <span class="o">=</span> <span class="n">qdict_bra</span><span class="p">[(</span><span class="n">q_bra</span><span class="p">,)]</span>
                <span class="n">B</span><span class="p">[</span><span class="n">slice_bra</span><span class="p">,</span> <span class="n">slice_ket</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">det_always</span> <span class="o">*</span> <span class="n">_tensor_block</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sometimes_matrix</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">new_sets_bra</span><span class="p">[</span><span class="n">slice_bra</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">new_sets_ket</span><span class="p">[</span><span class="n">slice_ket</span><span class="p">],</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">B</span><span class="o">.</span><span class="n">split_legs</span><span class="p">()</span>  <span class="c1"># splits the bra leg if `physical_leg`</span></div>
</div>



<span class="c1">#### High-level functions ####</span>
<span class="c1">#### -------------------- ####</span>


<div class="viewcode-block" id="correlation_matrix">
<a class="viewcode-back" href="../../reference/slater.html#temfpy.slater.correlation_matrix">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">correlation_matrix</span><span class="p">(</span><span class="n">H</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">N</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Ground-state correlation matrix of a mean-field Hamiltonian.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    H:</span>
<span class="sd">        Real-space mean-field Hamiltonian.</span>
<span class="sd">    N:</span>
<span class="sd">        Number of occupied orbitals.</span>

<span class="sd">        If not specified (default), all orbitals with negative energy are filled.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        C: :class:`np.ndarray`</span>
<span class="sd">            The correlation matrix, :math:`C_{ij} = \langle c_j^\dagger c_i\rangle`.</span>
<span class="sd">        N: :class:`int`</span>
<span class="sd">            The number of occupied orbitals.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">e</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">eigh</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">N</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">occupied</span> <span class="o">=</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span> <span class="n">occupied</span><span class="p">]</span>  <span class="c1"># filter out occupied orbitals</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">occupied</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span> <span class="p">:</span><span class="n">N</span><span class="p">]</span>  <span class="c1"># fill lowest N orbitals</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">v</span> <span class="o">@</span> <span class="n">HT</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-14</span><span class="p">):</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">real</span>  <span class="c1"># eliminate zero imaginary parts</span>
    <span class="k">return</span> <span class="n">C</span><span class="p">,</span> <span class="n">N</span></div>



<div class="viewcode-block" id="spinful_correlation_matrix">
<a class="viewcode-back" href="../../reference/slater.html#temfpy.slater.spinful_correlation_matrix">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">spinful_correlation_matrix</span><span class="p">(</span><span class="n">C</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ph</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Enlarged correlation matrix for spinful fermions.</span>

<span class="sd">    Doubles the size of the correlation matrix: even and odd sites</span>
<span class="sd">    in the new matrix correspond to up- and down-spin orbitals correlated</span>
<span class="sd">    among themselves like the input correlation matrix, and uncorrelated</span>
<span class="sd">    between up and down spins.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    C:</span>
<span class="sd">        The correlation matrix, :math:`C_{ij} = \langle c_j^\dagger c_i\rangle`.</span>
<span class="sd">    ph:</span>
<span class="sd">        Whether the down-spin (odd index) orbitals should be particle-hole</span>
<span class="sd">        transformed (:math:`c_{i\downarrow} \leftrightarrow c_{i\downarrow}^\dagger`)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        The enlarged spinful correlation matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">assert</span> <span class="n">n</span> <span class="o">==</span> <span class="n">m</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Got non-square </span><span class="si">{</span><span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> correlation matrix&quot;</span>

    <span class="n">C2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">C</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">C2</span><span class="p">[::</span><span class="mi">2</span><span class="p">,</span> <span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span>
    <span class="k">if</span> <span class="n">ph</span><span class="p">:</span>
        <span class="n">C2</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="n">C</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">C2</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span>

    <span class="k">return</span> <span class="n">C2</span></div>



<div class="viewcode-block" id="C_to_MPS">
<a class="viewcode-back" href="../../reference/slater.html#temfpy.slater.C_to_MPS">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">C_to_MPS</span><span class="p">(</span>
    <span class="n">C</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">trunc_par</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="n">StoppingCondition</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">diag_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_DIAG_TOL</span><span class="p">,</span>
    <span class="n">ortho_center</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">spinful</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;simple&quot;</span><span class="p">,</span> <span class="s2">&quot;PH&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">networks</span><span class="o">.</span><span class="n">MPS</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;MPS representation of a Slater determinant from its correlation matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    C:</span>
<span class="sd">        The correlation matrix, :math:`C_{ij} = \langle c_j^\dagger c_i\rangle`.</span>
<span class="sd">    trunc_par:</span>
<span class="sd">        Specifies which Schmidt states should be kept.</span>

<span class="sd">        Must be either a :class:`~temfpy.schmidt_utils.StoppingCondition` object</span>
<span class="sd">        or a dictionary with matching keys.</span>

<span class="sd">        Only specify the field `sectors` if you know what you are doing!!</span>
<span class="sd">    diag_tol:</span>
<span class="sd">        Largest allowed offdiagonal matrix element in diagonalised / SVD</span>
<span class="sd">        correlation submatrices before an error is raised.</span>
<span class="sd">    ortho_center:</span>
<span class="sd">        Orthogonality centre of the mixed canonical MPS.</span>
<span class="sd">        Midpoint of the chain by default.</span>
<span class="sd">    spinful:</span>
<span class="sd">        Whether to treat the input correlation matrix as describing a</span>
<span class="sd">        spin-rotation symmetric state of spinful fermions or not (``None``),</span>
<span class="sd">        either with (``&quot;PH&quot;``) or without (``&quot;simple&quot;``) particle-hole</span>
<span class="sd">        rotation in the down-spin sector.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        The wave function as a TeNPy :class:`~tenpy.networks.mps.MPS` object.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    - If :attr:`trunc_par.svd_min` is not provided, the truncation threshold</span>
<span class="sd">      defaults to 1e-6.</span>
<span class="sd">    - If :attr:`trunc_par.degeneracy_tol` is not provided, the degeneracy tolerance</span>
<span class="sd">      defaults to 1e-12.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">trunc_par</span> <span class="o">=</span> <span class="n">to_stopping_condition</span><span class="p">(</span><span class="n">trunc_par</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">spinful</span> <span class="o">==</span> <span class="s2">&quot;simple&quot;</span><span class="p">:</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">spinful_correlation_matrix</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">spinful</span> <span class="o">==</span> <span class="s2">&quot;PH&quot;</span><span class="p">:</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">spinful_correlation_matrix</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">spinful</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;`spinful` must be &#39;simple&#39;, &#39;PH&#39;, or `None`, got </span><span class="si">{</span><span class="n">spinful</span><span class="si">!r}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">L</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Got non-square </span><span class="si">{</span><span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> correlation matrix&quot;</span>

    <span class="c1"># lists for accumulating the tensors and singular values</span>
    <span class="n">tensors</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">L</span>
    <span class="n">Î»s</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Main bipartition, in the middle if not otherwise specified</span>
    <span class="n">ortho_center</span> <span class="o">=</span> <span class="n">ortho_center</span> <span class="ow">or</span> <span class="n">L</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Central bond </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ortho_center</span><span class="p">)</span>
    <span class="n">Schmidt_center</span> <span class="o">=</span> <span class="n">SchmidtVectors</span><span class="o">.</span><span class="n">from_correlation_matrix</span><span class="p">(</span>
        <span class="n">C</span><span class="p">,</span> <span class="n">ortho_center</span><span class="p">,</span> <span class="n">trunc_par</span><span class="o">=</span><span class="n">trunc_par</span><span class="p">,</span> <span class="n">diag_tol</span><span class="o">=</span><span class="n">diag_tol</span>
    <span class="p">)</span>
    <span class="n">Î»s</span><span class="p">[</span><span class="n">ortho_center</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalize_SV</span><span class="p">(</span><span class="n">Schmidt_center</span><span class="o">.</span><span class="n">schmidt_values</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>

    <span class="c1"># Right half of the chain</span>
    <span class="c1"># -----------------------</span>
    <span class="n">Schmidt</span> <span class="o">=</span> <span class="n">Schmidt_center</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ortho_center</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Site </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">Schmidt_new</span> <span class="o">=</span> <span class="n">SchmidtVectors</span><span class="o">.</span><span class="n">from_correlation_matrix</span><span class="p">(</span>
            <span class="n">C</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">trunc_par</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="n">diag_tol</span><span class="o">=</span><span class="n">diag_tol</span>
        <span class="p">)</span>
        <span class="n">Î»s</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalize_SV</span><span class="p">(</span><span class="n">Schmidt_new</span><span class="o">.</span><span class="n">schmidt_values</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>

        <span class="c1"># compute the tensor</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">MPSTensorData</span><span class="o">.</span><span class="n">from_schmidt_vectors</span><span class="p">(</span><span class="n">Schmidt_new</span><span class="p">,</span> <span class="n">Schmidt</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">)</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">to_npc_array</span><span class="p">()</span>
        <span class="n">tensors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Tensor norm on site </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">npc</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">Î»s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="mf">0.5</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">logger</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">):</span>
            <span class="c1"># check accuracy of canonical form</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="p">[[</span><span class="s2">&quot;vR&quot;</span><span class="p">,</span> <span class="s2">&quot;p&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;vR*&quot;</span><span class="p">,</span> <span class="s2">&quot;p*&quot;</span><span class="p">]])</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">to_ndarray</span><span class="p">()</span>
            <span class="n">deviation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">e</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)))</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;RMS RC deviation: </span><span class="si">{</span><span class="n">deviation</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">Schmidt</span> <span class="o">=</span> <span class="n">Schmidt_new</span>

    <span class="c1"># Left half of the chain</span>
    <span class="c1"># ----------------------</span>
    <span class="n">Schmidt</span> <span class="o">=</span> <span class="n">Schmidt_center</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ortho_center</span><span class="p">)):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Site </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">Schmidt_new</span> <span class="o">=</span> <span class="n">SchmidtVectors</span><span class="o">.</span><span class="n">from_correlation_matrix</span><span class="p">(</span>
            <span class="n">C</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">trunc_par</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;L&quot;</span><span class="p">,</span> <span class="n">diag_tol</span><span class="o">=</span><span class="n">diag_tol</span>
        <span class="p">)</span>
        <span class="n">Î»s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalize_SV</span><span class="p">(</span><span class="n">Schmidt_new</span><span class="o">.</span><span class="n">schmidt_values</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>

        <span class="c1"># compute the tensor</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">MPSTensorData</span><span class="o">.</span><span class="n">from_schmidt_vectors</span><span class="p">(</span><span class="n">Schmidt_new</span><span class="p">,</span> <span class="n">Schmidt</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">to_npc_array</span><span class="p">()</span>
        <span class="n">tensors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Tensor norm on site </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">npc</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">Î»s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="mf">0.5</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">logger</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">):</span>
            <span class="c1"># check accuracy of left canonical form</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="p">[[</span><span class="s2">&quot;vL&quot;</span><span class="p">,</span> <span class="s2">&quot;p&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;vL*&quot;</span><span class="p">,</span> <span class="s2">&quot;p*&quot;</span><span class="p">]])</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">to_ndarray</span><span class="p">()</span>
            <span class="n">deviation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">e</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)))</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;RMS LC deviation: </span><span class="si">{</span><span class="n">deviation</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">Schmidt</span> <span class="o">=</span> <span class="n">Schmidt_new</span>

    <span class="n">form</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">ortho_center</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;B&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">L</span> <span class="o">-</span> <span class="n">ortho_center</span><span class="p">)</span>
    <span class="n">mps</span> <span class="o">=</span> <span class="n">networks</span><span class="o">.</span><span class="n">mps</span><span class="o">.</span><span class="n">MPS</span><span class="p">([</span><span class="n">fermion_site</span><span class="p">]</span> <span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="n">tensors</span><span class="p">,</span> <span class="n">Î»s</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="n">form</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mps</span></div>



<div class="viewcode-block" id="C_to_iMPS">
<a class="viewcode-back" href="../../reference/slater.html#temfpy.slater.C_to_iMPS">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">C_to_iMPS</span><span class="p">(</span>
    <span class="n">C_short</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">C_long</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">trunc_par</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="n">StoppingCondition</span><span class="p">,</span>
    <span class="n">sites_per_cell</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">cut</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">diag_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_DIAG_TOL</span><span class="p">,</span>
    <span class="n">unitary_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">iMPS</span><span class="o">.</span><span class="n">_UNITARY_TOL</span><span class="p">,</span>
    <span class="n">schmidt_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">iMPS</span><span class="o">.</span><span class="n">_SCHMIDT_TOL</span><span class="p">,</span>
    <span class="n">spinful</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;simple&quot;</span><span class="p">,</span> <span class="s2">&quot;PH&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">networks</span><span class="o">.</span><span class="n">MPS</span><span class="p">,</span> <span class="n">iMPS</span><span class="o">.</span><span class="n">iMPSError</span><span class="p">]:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;iMPS representation of a Slater determinant from correlation matrices.</span>

<span class="sd">    The two correlation matrices are expected to represent the ground states</span>
<span class="sd">    of a gapped, translation invariant Hamiltonian on two system sizes that</span>
<span class="sd">    differ by one repeating unit cell.</span>

<span class="sd">    The method is analogous to :func:`.iMPS.MPS_to_iMPS`, with two differences:</span>

<span class="sd">    - No explicit MPS tensors are computed for the environment of the iMPS unit</span>
<span class="sd">      cell. Instead, the Schmidt vector overlaps needed for gauge fixing are</span>
<span class="sd">      computed using the Slater determinant overlap formulas implemented in</span>
<span class="sd">      :class:`MPSTensorData`.</span>
<span class="sd">    - The rightmost tensor is computed directly using the right Schmidt vectors</span>
<span class="sd">      of the shorter chain. This means that no separate :class:`~.iMPS.iMPSError`\ s</span>
<span class="sd">      are returned for the right side.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    C_short:</span>
<span class="sd">        The correlation matrix, :math:`C_{ij} = \langle c_j^\dagger c_i\rangle`,</span>
<span class="sd">        for the shorter chain.</span>
<span class="sd">    C_long:</span>
<span class="sd">        The correlation matrix for the longer chain.</span>
<span class="sd">    trunc_par:</span>
<span class="sd">        Specifies which Schmidt states should be kept.</span>

<span class="sd">        Must be either a :class:`~temfpy.schmidt_utils.StoppingCondition` object</span>
<span class="sd">        or a dictionary with matching keys.</span>

<span class="sd">        Only specify the field ``sectors`` if you know what you are doing!!</span>
<span class="sd">    sites_per_cell:</span>
<span class="sd">        Size of the iMPS unit cell.</span>
<span class="sd">    cut:</span>
<span class="sd">        First site of the repeating unit cell in ``C_long``.</span>
<span class="sd">    diag_tol:</span>
<span class="sd">        Largest allowed offdiagonal matrix element in diagonalised / SVD</span>
<span class="sd">        correlation submatrices before an error is raised.</span>
<span class="sd">    unitary_tol:</span>
<span class="sd">        Maximum deviation of the gauge rotation matrices from unitarity</span>
<span class="sd">        before a warning is raised.</span>
<span class="sd">    schmidt_tol:</span>
<span class="sd">        Maximum mixing of unequal Schmidt values by the gauge rotation matrices</span>
<span class="sd">        before a warning is raised.</span>
<span class="sd">    spinful:</span>
<span class="sd">        Whether to treat the input correlation matrices as describing a</span>
<span class="sd">        spin-rotation symmetric state of spinful fermions or not (``None``),</span>
<span class="sd">        either with (``&quot;PH&quot;``) or without (``&quot;simple&quot;``) particle-hole</span>
<span class="sd">        rotation in the down-spin sector.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    iMPS: :class:`~tenpy.networks.mps.MPS`</span>
<span class="sd">        iMPS with unit cell size ``sites_per_cell``, constructed from the</span>
<span class="sd">        additional unit cell of ``mps_long``.</span>
<span class="sd">    validation_metric: :class:`~.iMPS.iMPSError`</span>
<span class="sd">        Errors introduced during the conversion.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    - If :attr:`trunc_par.svd_min` is not provided, the truncation threshold</span>
<span class="sd">      defaults to 1e-6.</span>
<span class="sd">    - If :attr:`trunc_par.degeneracy_tol` is not provided, the degeneracy tolerance</span>
<span class="sd">      defaults to 1e-12.</span>
<span class="sd">    - If ``spinful`` fermions are requested, ``sites_per_cell`` and ``cut`` still</span>
<span class="sd">      refer to indices in the original correlation matrices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">trunc_par</span> <span class="o">=</span> <span class="n">to_stopping_condition</span><span class="p">(</span><span class="n">trunc_par</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">spinful</span> <span class="o">==</span> <span class="s2">&quot;simple&quot;</span><span class="p">:</span>
        <span class="n">C_short</span> <span class="o">=</span> <span class="n">spinful_correlation_matrix</span><span class="p">(</span><span class="n">C_short</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">C_long</span> <span class="o">=</span> <span class="n">spinful_correlation_matrix</span><span class="p">(</span><span class="n">C_long</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">sites_per_cell</span> <span class="o">*=</span> <span class="mi">2</span>
        <span class="n">cut</span> <span class="o">*=</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="n">spinful</span> <span class="o">==</span> <span class="s2">&quot;PH&quot;</span><span class="p">:</span>
        <span class="n">C_short</span> <span class="o">=</span> <span class="n">spinful_correlation_matrix</span><span class="p">(</span><span class="n">C_short</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">C_long</span> <span class="o">=</span> <span class="n">spinful_correlation_matrix</span><span class="p">(</span><span class="n">C_long</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">sites_per_cell</span> <span class="o">*=</span> <span class="mi">2</span>
        <span class="n">cut</span> <span class="o">*=</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="n">spinful</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;`spinful` must be &#39;simple&#39;, &#39;PH&#39;, or `None`, got </span><span class="si">{</span><span class="n">spinful</span><span class="si">!r}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">L_short</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">C_short</span><span class="p">)</span>
    <span class="n">err</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Got non-square </span><span class="si">{</span><span class="n">C_short</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> correlation matrix&quot;</span>
    <span class="k">assert</span> <span class="n">C_short</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">L_short</span><span class="p">,</span> <span class="n">L_short</span><span class="p">),</span> <span class="n">err</span>

    <span class="n">L_long</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">C_long</span><span class="p">)</span>
    <span class="n">err</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Got non-square </span><span class="si">{</span><span class="n">C_long</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> correlation matrix&quot;</span>
    <span class="k">assert</span> <span class="n">C_long</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">L_long</span><span class="p">,</span> <span class="n">L_long</span><span class="p">),</span> <span class="n">err</span>

    <span class="k">assert</span> <span class="n">L_short</span> <span class="o">+</span> <span class="n">sites_per_cell</span> <span class="o">==</span> <span class="n">L_long</span><span class="p">,</span> <span class="p">(</span>
        <span class="s2">&quot;The given two MPS must differ by one unit cell, got &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">L_long</span><span class="si">}</span><span class="s2"> - </span><span class="si">{</span><span class="n">L_short</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">sites_per_cell</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>

    <span class="c1"># lists for accumulating the tensors and singular values</span>
    <span class="n">tensors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Î»s</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Reference bipartition in the two chains</span>
    <span class="n">Schmidt_short</span> <span class="o">=</span> <span class="n">SchmidtVectors</span><span class="o">.</span><span class="n">from_correlation_matrix</span><span class="p">(</span>
        <span class="n">C_short</span><span class="p">,</span> <span class="n">cut</span><span class="p">,</span> <span class="n">trunc_par</span><span class="o">=</span><span class="n">trunc_par</span><span class="p">,</span> <span class="n">diag_tol</span><span class="o">=</span><span class="n">diag_tol</span>
    <span class="p">)</span>
    <span class="n">Î»s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">normalize_SV</span><span class="p">(</span><span class="n">Schmidt_short</span><span class="o">.</span><span class="n">schmidt_values</span><span class="p">,</span> <span class="n">logger</span><span class="p">))</span>
    <span class="n">Schmidt_long</span> <span class="o">=</span> <span class="n">SchmidtVectors</span><span class="o">.</span><span class="n">from_correlation_matrix</span><span class="p">(</span>
        <span class="n">C_long</span><span class="p">,</span> <span class="n">cut</span><span class="p">,</span> <span class="n">trunc_par</span><span class="o">=</span><span class="n">trunc_par</span><span class="p">,</span> <span class="n">diag_tol</span><span class="o">=</span><span class="n">diag_tol</span>
    <span class="p">)</span>

    <span class="c1"># Right canonical tensors</span>
    <span class="n">Schmidt</span> <span class="o">=</span> <span class="n">Schmidt_long</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sites_per_cell</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Site </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">sites_per_cell</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">Schmidt_new</span> <span class="o">=</span> <span class="n">Schmidt_short</span>  <span class="c1"># compare with right env of short chain</span>
            <span class="n">Î»s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Î»s</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># ensure first and last Î» identical</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Schmidt_new</span> <span class="o">=</span> <span class="n">SchmidtVectors</span><span class="o">.</span><span class="n">from_correlation_matrix</span><span class="p">(</span>
                <span class="n">C_long</span><span class="p">,</span> <span class="n">cut</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">trunc_par</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="n">diag_tol</span><span class="o">=</span><span class="n">diag_tol</span>
            <span class="p">)</span>
            <span class="n">Î»s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">normalize_SV</span><span class="p">(</span><span class="n">Schmidt_new</span><span class="o">.</span><span class="n">schmidt_values</span><span class="p">,</span> <span class="n">logger</span><span class="p">))</span>

        <span class="c1"># compute the tensor</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">MPSTensorData</span><span class="o">.</span><span class="n">from_schmidt_vectors</span><span class="p">(</span><span class="n">Schmidt_new</span><span class="p">,</span> <span class="n">Schmidt</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">)</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">to_npc_array</span><span class="p">()</span>
        <span class="n">tensors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Tensor norm on site </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">npc</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">Î»s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="mf">0.5</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">logger</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">):</span>
            <span class="c1"># check accuracy of canonical form</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="p">[[</span><span class="s2">&quot;vR&quot;</span><span class="p">,</span> <span class="s2">&quot;p&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;vR*&quot;</span><span class="p">,</span> <span class="s2">&quot;p*&quot;</span><span class="p">]])</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">to_ndarray</span><span class="p">()</span>
            <span class="n">deviation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">e</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)))</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;RMS RC deviation: </span><span class="si">{</span><span class="n">deviation</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">Schmidt</span> <span class="o">=</span> <span class="n">Schmidt_new</span>

    <span class="c1"># Gauge fix first tensor</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">MPSTensorData</span><span class="o">.</span><span class="n">from_schmidt_vectors</span><span class="p">(</span><span class="n">Schmidt_short</span><span class="p">,</span> <span class="n">Schmidt_long</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">)</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">to_npc_array</span><span class="p">()</span>
    <span class="n">C</span><span class="p">,</span> <span class="n">left_unitary</span><span class="p">,</span> <span class="n">left_schmidt</span> <span class="o">=</span> <span class="n">iMPS</span><span class="o">.</span><span class="n">basis_rotation</span><span class="p">(</span>
        <span class="n">C</span><span class="p">,</span>
        <span class="n">Schmidt_short</span><span class="o">.</span><span class="n">schmidt_values</span><span class="p">,</span>
        <span class="n">Schmidt_long</span><span class="o">.</span><span class="n">schmidt_values</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
        <span class="n">unitary_tol</span><span class="o">=</span><span class="n">unitary_tol</span><span class="p">,</span>
        <span class="n">schmidt_tol</span><span class="o">=</span><span class="n">schmidt_tol</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;vR&quot;</span><span class="p">,</span> <span class="s2">&quot;vL&quot;</span><span class="p">])</span>

    <span class="n">iMPS_</span> <span class="o">=</span> <span class="n">networks</span><span class="o">.</span><span class="n">MPS</span><span class="p">(</span>
        <span class="p">[</span><span class="n">fermion_site</span><span class="p">]</span> <span class="o">*</span> <span class="n">sites_per_cell</span><span class="p">,</span> <span class="n">tensors</span><span class="p">,</span> <span class="n">Î»s</span><span class="p">,</span> <span class="n">bc</span><span class="o">=</span><span class="s2">&quot;infinite&quot;</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="s2">&quot;B&quot;</span>
    <span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">iMPS</span><span class="o">.</span><span class="n">iMPSError</span><span class="p">(</span><span class="n">left_unitary</span><span class="p">,</span> <span class="n">left_schmidt</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">iMPS_</span><span class="p">,</span> <span class="n">error</span></div>



<div class="viewcode-block" id="H_to_MPS">
<a class="viewcode-back" href="../../reference/slater.html#temfpy.slater.H_to_MPS">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">H_to_MPS</span><span class="p">(</span>
    <span class="n">H</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">trunc_par</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="n">StoppingCondition</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">diag_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_DIAG_TOL</span><span class="p">,</span>
    <span class="n">ortho_center</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">spinful</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;simple&quot;</span><span class="p">,</span> <span class="s2">&quot;PH&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">networks</span><span class="o">.</span><span class="n">MPS</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;MPS representation of a Slater determinant from its single body Hamiltonian.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    H:</span>
<span class="sd">        The single body Hamiltonian :math:`H_{ij}`.</span>
<span class="sd">    trunc_par:</span>
<span class="sd">        Specifies which Schmidt states should be kept.</span>

<span class="sd">        Must be either a :class:`~temfpy.schmidt_utils.StoppingCondition` object</span>
<span class="sd">        or a dictionary with matching keys.</span>

<span class="sd">        Only specify the field `sectors` if you know what you are doing!!</span>
<span class="sd">    diag_tol:</span>
<span class="sd">        Largest allowed offdiagonal matrix element in diagonalised / SVD</span>
<span class="sd">        correlation submatrices before an error is raised.</span>
<span class="sd">    ortho_center:</span>
<span class="sd">        Orthogonality centre of the mixed canonical MPS.</span>
<span class="sd">        Midpoint of the chain by default.</span>
<span class="sd">    spinful:</span>
<span class="sd">        Whether to treat the input single particle Hamiltonian as describing a</span>
<span class="sd">        spin-rotation symmetric state of spinful fermions or not (``None``),</span>
<span class="sd">        either with (``&quot;PH&quot;``) or without (``&quot;simple&quot;``) particle-hole</span>
<span class="sd">        rotation in the down-spin sector.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    The wave function as a TeNPy :class:`~tenpy.networks.mps.MPS` object.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    - If :attr:`trunc_par.svd_min` is not provided, the truncation threshold</span>
<span class="sd">      defaults to 1e-6.</span>
<span class="sd">    - If :attr:`trunc_par.degeneracy_tol` is not provided, the degeneracy tolerance</span>
<span class="sd">      defaults to 1e-12.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">C</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">correlation_matrix</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">C_to_MPS</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">trunc_par</span><span class="p">,</span> <span class="n">diag_tol</span><span class="o">=</span><span class="n">diag_tol</span><span class="p">,</span> <span class="n">ortho_center</span><span class="o">=</span><span class="n">ortho_center</span><span class="p">,</span> <span class="n">spinful</span><span class="o">=</span><span class="n">spinful</span><span class="p">)</span></div>


    
<div class="viewcode-block" id="H_to_iMPS">
<a class="viewcode-back" href="../../reference/slater.html#temfpy.slater.H_to_iMPS">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">H_to_iMPS</span><span class="p">(</span>
    <span class="n">H_short</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">H_long</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">trunc_par</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="n">StoppingCondition</span><span class="p">,</span>
    <span class="n">sites_per_cell</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">cut</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">diag_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_DIAG_TOL</span><span class="p">,</span>
    <span class="n">unitary_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">iMPS</span><span class="o">.</span><span class="n">_UNITARY_TOL</span><span class="p">,</span>
    <span class="n">schmidt_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">iMPS</span><span class="o">.</span><span class="n">_SCHMIDT_TOL</span><span class="p">,</span>
    <span class="n">spinful</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;simple&quot;</span><span class="p">,</span> <span class="s2">&quot;PH&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">networks</span><span class="o">.</span><span class="n">MPS</span><span class="p">,</span> <span class="n">iMPS</span><span class="o">.</span><span class="n">iMPSError</span><span class="p">]:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;iMPS representation of a Slater determinant from single particle Hamiltonians.</span>

<span class="sd">    It is expected that the two single-particle Hamiltonians describe two </span>
<span class="sd">    translation-invariant systems that differ by one repeating unit cell.</span>

<span class="sd">    The method is analogous to :func:`.iMPS.MPS_to_iMPS`, with two differences:</span>

<span class="sd">    - No explicit MPS tensors are computed for the environment of the iMPS unit</span>
<span class="sd">      cell. Instead, the Schmidt vector overlaps needed for gauge fixing are</span>
<span class="sd">      computed using the Slater determinant overlap formulas implemented in</span>
<span class="sd">      :class:`MPSTensorData`.</span>
<span class="sd">    - The rightmost tensor is computed directly using the right Schmidt vectors</span>
<span class="sd">      of the shorter chain. This means that no separate :class:`~.iMPS.iMPSError`\ s</span>
<span class="sd">      are returned for the right side.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    H_short:</span>
<span class="sd">        The single particle Hamiltonian :math:`H_{ij}` for the shorter chain.</span>
<span class="sd">    H_long:</span>
<span class="sd">        The single particle Hamiltonian for the longer chain.</span>
<span class="sd">    trunc_par:</span>
<span class="sd">        Specifies which Schmidt states should be kept.</span>

<span class="sd">        Must be either a :class:`~temfpy.schmidt_utils.StoppingCondition` object</span>
<span class="sd">        or a dictionary with matching keys.</span>

<span class="sd">        Only specify the field ``sectors`` if you know what you are doing!!</span>
<span class="sd">    sites_per_cell:</span>
<span class="sd">        Size of the iMPS unit cell.</span>
<span class="sd">    cut:</span>
<span class="sd">        First site of the repeating unit cell in ``H_long``.</span>
<span class="sd">    diag_tol:</span>
<span class="sd">        Largest allowed offdiagonal matrix element in diagonalised / SVD</span>
<span class="sd">        correlation submatrices before an error is raised.</span>
<span class="sd">    unitary_tol:</span>
<span class="sd">        Maximum deviation of the gauge rotation matrices from unitarity</span>
<span class="sd">        before a warning is raised.</span>
<span class="sd">    schmidt_tol:</span>
<span class="sd">        Maximum mixing of unequal Schmidt values by the gauge rotation matrices</span>
<span class="sd">        before a warning is raised.</span>
<span class="sd">    spinful:</span>
<span class="sd">        Whether to treat the input single particle Hamiltonians as describing a</span>
<span class="sd">        spin-rotation symmetric state of spinful fermions or not (``None``),</span>
<span class="sd">        either with (``&quot;PH&quot;``) or without (``&quot;simple&quot;``) particle-hole</span>
<span class="sd">        rotation in the down-spin sector.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    iMPS: :class:`~tenpy.networks.mps.MPS`</span>
<span class="sd">        iMPS with unit cell size ``sites_per_cell``, constructed from the</span>
<span class="sd">        additional unit cell of ``mps_long``.</span>
<span class="sd">    validation_metric: :class:`~.iMPS.iMPSError`</span>
<span class="sd">        Errors introduced during the conversion.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    - If :attr:`trunc_par.svd_min` is not provided, the truncation threshold</span>
<span class="sd">      defaults to 1e-6.</span>
<span class="sd">    - If :attr:`trunc_par.degeneracy_tol` is not provided, the degeneracy tolerance</span>
<span class="sd">      defaults to 1e-12.</span>
<span class="sd">    - If ``spinful`` fermions are requested, ``sites_per_cell`` and ``cut`` still</span>
<span class="sd">      refer to indices in the original correlation matrices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">C_short</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">correlation_matrix</span><span class="p">(</span><span class="n">H_short</span><span class="p">)</span>
    <span class="n">C_long</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">correlation_matrix</span><span class="p">(</span><span class="n">H_long</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">C_to_iMPS</span><span class="p">(</span>
        <span class="n">C_short</span><span class="p">,</span>
        <span class="n">C_long</span><span class="p">,</span>
        <span class="n">trunc_par</span><span class="p">,</span>
        <span class="n">sites_per_cell</span><span class="p">,</span>
        <span class="n">cut</span><span class="p">,</span>
        <span class="n">diag_tol</span><span class="o">=</span><span class="n">diag_tol</span><span class="p">,</span>
        <span class="n">unitary_tol</span><span class="o">=</span><span class="n">unitary_tol</span><span class="p">,</span>
        <span class="n">schmidt_tol</span><span class="o">=</span><span class="n">schmidt_tol</span><span class="p">,</span>
        <span class="n">spinful</span><span class="o">=</span><span class="n">spinful</span><span class="p">,</span>
    <span class="p">)</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Simon Hans Hille, Attila SzabÃ³.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>